/**
 * Autogenerated by Thrift Compiler (0.9.0-dev)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
package Snaphappi {

import org.apache.thrift.Set;
import flash.utils.ByteArray;
import flash.utils.Dictionary;
import com.hurlant.math.BigInteger;

import org.apache.thrift.*;
import org.apache.thrift.meta_data.*;
import org.apache.thrift.protocol.*;


  public class TaskProcessor implements TProcessor {
    public function TaskProcessor(iface:Task)
    {
      iface_ = iface;
      PROCESS_MAP["AddFolder"] = AddFolder();
      PROCESS_MAP["RemoveFolder"] = RemoveFolder();
      PROCESS_MAP["GetDeviceID"] = GetDeviceID();
      PROCESS_MAP["GetFileCount"] = GetFileCount();
      PROCESS_MAP["GetFiles"] = GetFiles();
      PROCESS_MAP["GetFolders"] = GetFolders();
      PROCESS_MAP["GetState"] = GetState();
      PROCESS_MAP["GetWatchedFolders"] = GetWatchedFolders();
      PROCESS_MAP["ReportFileCount"] = ReportFileCount();
      PROCESS_MAP["ReportFolderNotFound"] = ReportFolderNotFound();
      PROCESS_MAP["ReportFolderUploadComplete"] = ReportFolderUploadComplete();
      PROCESS_MAP["ReportUploadFailed"] = ReportUploadFailed();
      PROCESS_MAP["UploadFile"] = UploadFile();
    }

    private var iface_:Task;
    protected const PROCESS_MAP:Dictionary = new Dictionary();

    public function process(iprot:TProtocol, oprot:TProtocol):Boolean
    {
      var msg:TMessage = iprot.readMessageBegin();
      var fn:Function = PROCESS_MAP[msg.name];
      if (fn == null) {
        TProtocolUtil.skip(iprot, TType.STRUCT);
        iprot.readMessageEnd();
        var x:TApplicationError = new TApplicationError(TApplicationError.UNKNOWN_METHOD, "Invalid method name: '"+msg.name+"'");
        oprot.writeMessageBegin(new TMessage(msg.name, TMessageType.EXCEPTION, msg.seqid));
        x.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        return true;
      }
      fn.call(this,msg.seqid, iprot, oprot);
      return true;
    }

    private function AddFolder():Function {
      return function(seqid:int, iprot:TProtocol, oprot:TProtocol):void
      {
        var args:AddFolder_args = new AddFolder_args();
        args.read(iprot);
        iprot.readMessageEnd();
        var result:AddFolder_result = new AddFolder_result();
        try {
          // sorry this operation is not supported yet
          throw new Error("This is not yet supported");
        } catch (systemException:SystemException) {
          result.systemException = systemException;
        } catch (th:Error) {
          trace("Internal error processing AddFolder", th);
          var x:TApplicationError = new TApplicationError(TApplicationError.INTERNAL_ERROR, "Internal error processing AddFolder");
          oprot.writeMessageBegin(new TMessage("AddFolder", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("AddFolder", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private function RemoveFolder():Function {
      return function(seqid:int, iprot:TProtocol, oprot:TProtocol):void
      {
        var args:RemoveFolder_args = new RemoveFolder_args();
        args.read(iprot);
        iprot.readMessageEnd();
        var result:RemoveFolder_result = new RemoveFolder_result();
        try {
          // sorry this operation is not supported yet
          throw new Error("This is not yet supported");
        } catch (systemException:SystemException) {
          result.systemException = systemException;
        } catch (th:Error) {
          trace("Internal error processing RemoveFolder", th);
          var x:TApplicationError = new TApplicationError(TApplicationError.INTERNAL_ERROR, "Internal error processing RemoveFolder");
          oprot.writeMessageBegin(new TMessage("RemoveFolder", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("RemoveFolder", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private function GetDeviceID():Function {
      return function(seqid:int, iprot:TProtocol, oprot:TProtocol):void
      {
        var args:GetDeviceID_args = new GetDeviceID_args();
        args.read(iprot);
        iprot.readMessageEnd();
        var result:GetDeviceID_result = new GetDeviceID_result();
        try {
          // sorry this operation is not supported yet
          throw new Error("This is not yet supported");
        } catch (systemException:SystemException) {
          result.systemException = systemException;
        } catch (th:Error) {
          trace("Internal error processing GetDeviceID", th);
          var x:TApplicationError = new TApplicationError(TApplicationError.INTERNAL_ERROR, "Internal error processing GetDeviceID");
          oprot.writeMessageBegin(new TMessage("GetDeviceID", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("GetDeviceID", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private function GetFileCount():Function {
      return function(seqid:int, iprot:TProtocol, oprot:TProtocol):void
      {
        var args:GetFileCount_args = new GetFileCount_args();
        args.read(iprot);
        iprot.readMessageEnd();
        var result:GetFileCount_result = new GetFileCount_result();
        try {
          // sorry this operation is not supported yet
          throw new Error("This is not yet supported");
          result.setSuccessIsSet(true);
        } catch (systemException:SystemException) {
          result.systemException = systemException;
        } catch (th:Error) {
          trace("Internal error processing GetFileCount", th);
          var x:TApplicationError = new TApplicationError(TApplicationError.INTERNAL_ERROR, "Internal error processing GetFileCount");
          oprot.writeMessageBegin(new TMessage("GetFileCount", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("GetFileCount", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private function GetFiles():Function {
      return function(seqid:int, iprot:TProtocol, oprot:TProtocol):void
      {
        var args:GetFiles_args = new GetFiles_args();
        args.read(iprot);
        iprot.readMessageEnd();
        var result:GetFiles_result = new GetFiles_result();
        try {
          // sorry this operation is not supported yet
          throw new Error("This is not yet supported");
        } catch (systemException:SystemException) {
          result.systemException = systemException;
        } catch (th:Error) {
          trace("Internal error processing GetFiles", th);
          var x:TApplicationError = new TApplicationError(TApplicationError.INTERNAL_ERROR, "Internal error processing GetFiles");
          oprot.writeMessageBegin(new TMessage("GetFiles", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("GetFiles", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private function GetFolders():Function {
      return function(seqid:int, iprot:TProtocol, oprot:TProtocol):void
      {
        var args:GetFolders_args = new GetFolders_args();
        args.read(iprot);
        iprot.readMessageEnd();
        var result:GetFolders_result = new GetFolders_result();
        try {
          // sorry this operation is not supported yet
          throw new Error("This is not yet supported");
        } catch (systemException:SystemException) {
          result.systemException = systemException;
        } catch (th:Error) {
          trace("Internal error processing GetFolders", th);
          var x:TApplicationError = new TApplicationError(TApplicationError.INTERNAL_ERROR, "Internal error processing GetFolders");
          oprot.writeMessageBegin(new TMessage("GetFolders", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("GetFolders", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private function GetState():Function {
      return function(seqid:int, iprot:TProtocol, oprot:TProtocol):void
      {
        var args:GetState_args = new GetState_args();
        args.read(iprot);
        iprot.readMessageEnd();
        var result:GetState_result = new GetState_result();
        try {
          // sorry this operation is not supported yet
          throw new Error("This is not yet supported");
        } catch (systemException:SystemException) {
          result.systemException = systemException;
        } catch (th:Error) {
          trace("Internal error processing GetState", th);
          var x:TApplicationError = new TApplicationError(TApplicationError.INTERNAL_ERROR, "Internal error processing GetState");
          oprot.writeMessageBegin(new TMessage("GetState", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("GetState", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private function GetWatchedFolders():Function {
      return function(seqid:int, iprot:TProtocol, oprot:TProtocol):void
      {
        var args:GetWatchedFolders_args = new GetWatchedFolders_args();
        args.read(iprot);
        iprot.readMessageEnd();
        var result:GetWatchedFolders_result = new GetWatchedFolders_result();
        try {
          // sorry this operation is not supported yet
          throw new Error("This is not yet supported");
        } catch (systemException:SystemException) {
          result.systemException = systemException;
        } catch (th:Error) {
          trace("Internal error processing GetWatchedFolders", th);
          var x:TApplicationError = new TApplicationError(TApplicationError.INTERNAL_ERROR, "Internal error processing GetWatchedFolders");
          oprot.writeMessageBegin(new TMessage("GetWatchedFolders", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("GetWatchedFolders", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private function ReportFileCount():Function {
      return function(seqid:int, iprot:TProtocol, oprot:TProtocol):void
      {
        var args:ReportFileCount_args = new ReportFileCount_args();
        args.read(iprot);
        iprot.readMessageEnd();
        var result:ReportFileCount_result = new ReportFileCount_result();
        try {
          // sorry this operation is not supported yet
          throw new Error("This is not yet supported");
        } catch (systemException:SystemException) {
          result.systemException = systemException;
        } catch (th:Error) {
          trace("Internal error processing ReportFileCount", th);
          var x:TApplicationError = new TApplicationError(TApplicationError.INTERNAL_ERROR, "Internal error processing ReportFileCount");
          oprot.writeMessageBegin(new TMessage("ReportFileCount", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("ReportFileCount", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private function ReportFolderNotFound():Function {
      return function(seqid:int, iprot:TProtocol, oprot:TProtocol):void
      {
        var args:ReportFolderNotFound_args = new ReportFolderNotFound_args();
        args.read(iprot);
        iprot.readMessageEnd();
        var result:ReportFolderNotFound_result = new ReportFolderNotFound_result();
        try {
          // sorry this operation is not supported yet
          throw new Error("This is not yet supported");
        } catch (systemException:SystemException) {
          result.systemException = systemException;
        } catch (th:Error) {
          trace("Internal error processing ReportFolderNotFound", th);
          var x:TApplicationError = new TApplicationError(TApplicationError.INTERNAL_ERROR, "Internal error processing ReportFolderNotFound");
          oprot.writeMessageBegin(new TMessage("ReportFolderNotFound", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("ReportFolderNotFound", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private function ReportFolderUploadComplete():Function {
      return function(seqid:int, iprot:TProtocol, oprot:TProtocol):void
      {
        var args:ReportFolderUploadComplete_args = new ReportFolderUploadComplete_args();
        args.read(iprot);
        iprot.readMessageEnd();
        var result:ReportFolderUploadComplete_result = new ReportFolderUploadComplete_result();
        try {
          // sorry this operation is not supported yet
          throw new Error("This is not yet supported");
        } catch (systemException:SystemException) {
          result.systemException = systemException;
        } catch (th:Error) {
          trace("Internal error processing ReportFolderUploadComplete", th);
          var x:TApplicationError = new TApplicationError(TApplicationError.INTERNAL_ERROR, "Internal error processing ReportFolderUploadComplete");
          oprot.writeMessageBegin(new TMessage("ReportFolderUploadComplete", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("ReportFolderUploadComplete", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private function ReportUploadFailed():Function {
      return function(seqid:int, iprot:TProtocol, oprot:TProtocol):void
      {
        var args:ReportUploadFailed_args = new ReportUploadFailed_args();
        args.read(iprot);
        iprot.readMessageEnd();
        var result:ReportUploadFailed_result = new ReportUploadFailed_result();
        try {
          // sorry this operation is not supported yet
          throw new Error("This is not yet supported");
        } catch (systemException:SystemException) {
          result.systemException = systemException;
        } catch (th:Error) {
          trace("Internal error processing ReportUploadFailed", th);
          var x:TApplicationError = new TApplicationError(TApplicationError.INTERNAL_ERROR, "Internal error processing ReportUploadFailed");
          oprot.writeMessageBegin(new TMessage("ReportUploadFailed", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("ReportUploadFailed", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private function UploadFile():Function {
      return function(seqid:int, iprot:TProtocol, oprot:TProtocol):void
      {
        var args:UploadFile_args = new UploadFile_args();
        args.read(iprot);
        iprot.readMessageEnd();
        var result:UploadFile_result = new UploadFile_result();
        try {
          // sorry this operation is not supported yet
          throw new Error("This is not yet supported");
        } catch (systemException:SystemException) {
          result.systemException = systemException;
        } catch (th:Error) {
          trace("Internal error processing UploadFile", th);
          var x:TApplicationError = new TApplicationError(TApplicationError.INTERNAL_ERROR, "Internal error processing UploadFile");
          oprot.writeMessageBegin(new TMessage("UploadFile", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("UploadFile", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

  }

}
import org.apache.thrift.Set;
import flash.utils.ByteArray;
import flash.utils.Dictionary;
import com.hurlant.math.BigInteger;

import org.apache.thrift.*;
import org.apache.thrift.meta_data.*;
import org.apache.thrift.protocol.*;


import Snaphappi.*;
class AddFolder_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("AddFolder_args");
  private static const ID_FIELD_DESC:TField = new TField("id", TType.STRUCT, 1);
  private static const PATH_FIELD_DESC:TField = new TField("path", TType.STRING, 2);

  private var _id:TaskID;
  public static const ID:int = 1;
  private var _path:String;
  public static const PATH:int = 2;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[ID] = new FieldMetaData("id", TFieldRequirementType.DEFAULT, 
        new StructMetaData(TType.STRUCT, TaskID));
    metaDataMap[PATH] = new FieldMetaData("path", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
  }
  {
    FieldMetaData.addStructMetaDataMap(AddFolder_args, metaDataMap);
  }

  public function AddFolder_args() {
  }

  public function get id():TaskID {
    return this._id;
  }

  public function set id(id:TaskID):void {
    this._id = id;
  }

  public function unsetId():void {
    this.id = null;
  }

  // Returns true if field id is set (has been assigned a value) and false otherwise
  public function isSetId():Boolean {
    return this.id != null;
  }

  public function get path():String {
    return this._path;
  }

  public function set path(path:String):void {
    this._path = path;
  }

  public function unsetPath():void {
    this.path = null;
  }

  // Returns true if field path is set (has been assigned a value) and false otherwise
  public function isSetPath():Boolean {
    return this.path != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case ID:
      if (value == null) {
        unsetId();
      } else {
        this.id = value;
      }
      break;

    case PATH:
      if (value == null) {
        unsetPath();
      } else {
        this.path = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case ID:
      return this.id;
    case PATH:
      return this.path;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case ID:
      return isSetId();
    case PATH:
      return isSetPath();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case ID:
          if (field.type == TType.STRUCT) {
            this.id = new TaskID();
            this.id.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case PATH:
          if (field.type == TType.STRING) {
            this.path = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    if (this.id != null) {
      oprot.writeFieldBegin(ID_FIELD_DESC);
      this.id.write(oprot);
      oprot.writeFieldEnd();
    }
    if (this.path != null) {
      oprot.writeFieldBegin(PATH_FIELD_DESC);
      oprot.writeString(this.path);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("AddFolder_args(");
    var first:Boolean = true;

    ret += "id:";
    if (this.id == null) {
      ret += "null";
    } else {
      ret += this.id;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "path:";
    if (this.path == null) {
      ret += "null";
    } else {
      ret += this.path;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class AddFolder_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("AddFolder_result");
  private static const SYSTEM_EXCEPTION_FIELD_DESC:TField = new TField("systemException", TType.STRUCT, 1);

  private var _systemException:SystemException;
  public static const SYSTEMEXCEPTION:int = 1;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[SYSTEMEXCEPTION] = new FieldMetaData("systemException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
  }
  {
    FieldMetaData.addStructMetaDataMap(AddFolder_result, metaDataMap);
  }

  public function AddFolder_result() {
  }

  public function get systemException():SystemException {
    return this._systemException;
  }

  public function set systemException(systemException:SystemException):void {
    this._systemException = systemException;
  }

  public function unsetSystemException():void {
    this.systemException = null;
  }

  // Returns true if field systemException is set (has been assigned a value) and false otherwise
  public function isSetSystemException():Boolean {
    return this.systemException != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case SYSTEMEXCEPTION:
      if (value == null) {
        unsetSystemException();
      } else {
        this.systemException = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case SYSTEMEXCEPTION:
      return this.systemException;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case SYSTEMEXCEPTION:
      return isSetSystemException();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case SYSTEMEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.systemException = new SystemException();
            this.systemException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    if (this.isSetSystemException()) {
      oprot.writeFieldBegin(SYSTEM_EXCEPTION_FIELD_DESC);
      this.systemException.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("AddFolder_result(");
    var first:Boolean = true;

    ret += "systemException:";
    if (this.systemException == null) {
      ret += "null";
    } else {
      ret += this.systemException;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class RemoveFolder_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("RemoveFolder_args");
  private static const ID_FIELD_DESC:TField = new TField("id", TType.STRUCT, 1);
  private static const PATH_FIELD_DESC:TField = new TField("path", TType.STRING, 2);

  private var _id:TaskID;
  public static const ID:int = 1;
  private var _path:String;
  public static const PATH:int = 2;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[ID] = new FieldMetaData("id", TFieldRequirementType.DEFAULT, 
        new StructMetaData(TType.STRUCT, TaskID));
    metaDataMap[PATH] = new FieldMetaData("path", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
  }
  {
    FieldMetaData.addStructMetaDataMap(RemoveFolder_args, metaDataMap);
  }

  public function RemoveFolder_args() {
  }

  public function get id():TaskID {
    return this._id;
  }

  public function set id(id:TaskID):void {
    this._id = id;
  }

  public function unsetId():void {
    this.id = null;
  }

  // Returns true if field id is set (has been assigned a value) and false otherwise
  public function isSetId():Boolean {
    return this.id != null;
  }

  public function get path():String {
    return this._path;
  }

  public function set path(path:String):void {
    this._path = path;
  }

  public function unsetPath():void {
    this.path = null;
  }

  // Returns true if field path is set (has been assigned a value) and false otherwise
  public function isSetPath():Boolean {
    return this.path != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case ID:
      if (value == null) {
        unsetId();
      } else {
        this.id = value;
      }
      break;

    case PATH:
      if (value == null) {
        unsetPath();
      } else {
        this.path = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case ID:
      return this.id;
    case PATH:
      return this.path;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case ID:
      return isSetId();
    case PATH:
      return isSetPath();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case ID:
          if (field.type == TType.STRUCT) {
            this.id = new TaskID();
            this.id.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case PATH:
          if (field.type == TType.STRING) {
            this.path = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    if (this.id != null) {
      oprot.writeFieldBegin(ID_FIELD_DESC);
      this.id.write(oprot);
      oprot.writeFieldEnd();
    }
    if (this.path != null) {
      oprot.writeFieldBegin(PATH_FIELD_DESC);
      oprot.writeString(this.path);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("RemoveFolder_args(");
    var first:Boolean = true;

    ret += "id:";
    if (this.id == null) {
      ret += "null";
    } else {
      ret += this.id;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "path:";
    if (this.path == null) {
      ret += "null";
    } else {
      ret += this.path;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class RemoveFolder_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("RemoveFolder_result");
  private static const SYSTEM_EXCEPTION_FIELD_DESC:TField = new TField("systemException", TType.STRUCT, 1);

  private var _systemException:SystemException;
  public static const SYSTEMEXCEPTION:int = 1;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[SYSTEMEXCEPTION] = new FieldMetaData("systemException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
  }
  {
    FieldMetaData.addStructMetaDataMap(RemoveFolder_result, metaDataMap);
  }

  public function RemoveFolder_result() {
  }

  public function get systemException():SystemException {
    return this._systemException;
  }

  public function set systemException(systemException:SystemException):void {
    this._systemException = systemException;
  }

  public function unsetSystemException():void {
    this.systemException = null;
  }

  // Returns true if field systemException is set (has been assigned a value) and false otherwise
  public function isSetSystemException():Boolean {
    return this.systemException != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case SYSTEMEXCEPTION:
      if (value == null) {
        unsetSystemException();
      } else {
        this.systemException = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case SYSTEMEXCEPTION:
      return this.systemException;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case SYSTEMEXCEPTION:
      return isSetSystemException();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case SYSTEMEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.systemException = new SystemException();
            this.systemException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    if (this.isSetSystemException()) {
      oprot.writeFieldBegin(SYSTEM_EXCEPTION_FIELD_DESC);
      this.systemException.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("RemoveFolder_result(");
    var first:Boolean = true;

    ret += "systemException:";
    if (this.systemException == null) {
      ret += "null";
    } else {
      ret += this.systemException;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class GetDeviceID_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("GetDeviceID_args");
  private static const AUTH_TOKEN_FIELD_DESC:TField = new TField("authToken", TType.STRING, 1);
  private static const SESSION_ID_FIELD_DESC:TField = new TField("sessionID", TType.STRING, 2);

  private var _authToken:String;
  public static const AUTHTOKEN:int = 1;
  private var _sessionID:String;
  public static const SESSIONID:int = 2;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[AUTHTOKEN] = new FieldMetaData("authToken", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
    metaDataMap[SESSIONID] = new FieldMetaData("sessionID", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
  }
  {
    FieldMetaData.addStructMetaDataMap(GetDeviceID_args, metaDataMap);
  }

  public function GetDeviceID_args() {
  }

  public function get authToken():String {
    return this._authToken;
  }

  public function set authToken(authToken:String):void {
    this._authToken = authToken;
  }

  public function unsetAuthToken():void {
    this.authToken = null;
  }

  // Returns true if field authToken is set (has been assigned a value) and false otherwise
  public function isSetAuthToken():Boolean {
    return this.authToken != null;
  }

  public function get sessionID():String {
    return this._sessionID;
  }

  public function set sessionID(sessionID:String):void {
    this._sessionID = sessionID;
  }

  public function unsetSessionID():void {
    this.sessionID = null;
  }

  // Returns true if field sessionID is set (has been assigned a value) and false otherwise
  public function isSetSessionID():Boolean {
    return this.sessionID != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case AUTHTOKEN:
      if (value == null) {
        unsetAuthToken();
      } else {
        this.authToken = value;
      }
      break;

    case SESSIONID:
      if (value == null) {
        unsetSessionID();
      } else {
        this.sessionID = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case AUTHTOKEN:
      return this.authToken;
    case SESSIONID:
      return this.sessionID;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case AUTHTOKEN:
      return isSetAuthToken();
    case SESSIONID:
      return isSetSessionID();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case AUTHTOKEN:
          if (field.type == TType.STRING) {
            this.authToken = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SESSIONID:
          if (field.type == TType.STRING) {
            this.sessionID = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    if (this.authToken != null) {
      oprot.writeFieldBegin(AUTH_TOKEN_FIELD_DESC);
      oprot.writeString(this.authToken);
      oprot.writeFieldEnd();
    }
    if (this.sessionID != null) {
      oprot.writeFieldBegin(SESSION_ID_FIELD_DESC);
      oprot.writeString(this.sessionID);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("GetDeviceID_args(");
    var first:Boolean = true;

    ret += "authToken:";
    if (this.authToken == null) {
      ret += "null";
    } else {
      ret += this.authToken;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "sessionID:";
    if (this.sessionID == null) {
      ret += "null";
    } else {
      ret += this.sessionID;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class GetDeviceID_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("GetDeviceID_result");
  private static const SUCCESS_FIELD_DESC:TField = new TField("success", TType.STRING, 0);
  private static const SYSTEM_EXCEPTION_FIELD_DESC:TField = new TField("systemException", TType.STRUCT, 1);

  private var _success:String;
  public static const SUCCESS:int = 0;
  private var _systemException:SystemException;
  public static const SYSTEMEXCEPTION:int = 1;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[SUCCESS] = new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
    metaDataMap[SYSTEMEXCEPTION] = new FieldMetaData("systemException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
  }
  {
    FieldMetaData.addStructMetaDataMap(GetDeviceID_result, metaDataMap);
  }

  public function GetDeviceID_result() {
  }

  public function get success():String {
    return this._success;
  }

  public function set success(success:String):void {
    this._success = success;
  }

  public function unsetSuccess():void {
    this.success = null;
  }

  // Returns true if field success is set (has been assigned a value) and false otherwise
  public function isSetSuccess():Boolean {
    return this.success != null;
  }

  public function get systemException():SystemException {
    return this._systemException;
  }

  public function set systemException(systemException:SystemException):void {
    this._systemException = systemException;
  }

  public function unsetSystemException():void {
    this.systemException = null;
  }

  // Returns true if field systemException is set (has been assigned a value) and false otherwise
  public function isSetSystemException():Boolean {
    return this.systemException != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case SUCCESS:
      if (value == null) {
        unsetSuccess();
      } else {
        this.success = value;
      }
      break;

    case SYSTEMEXCEPTION:
      if (value == null) {
        unsetSystemException();
      } else {
        this.systemException = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case SUCCESS:
      return this.success;
    case SYSTEMEXCEPTION:
      return this.systemException;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case SUCCESS:
      return isSetSuccess();
    case SYSTEMEXCEPTION:
      return isSetSystemException();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case SUCCESS:
          if (field.type == TType.STRING) {
            this.success = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SYSTEMEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.systemException = new SystemException();
            this.systemException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
      oprot.writeString(this.success);
      oprot.writeFieldEnd();
    } else if (this.isSetSystemException()) {
      oprot.writeFieldBegin(SYSTEM_EXCEPTION_FIELD_DESC);
      this.systemException.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("GetDeviceID_result(");
    var first:Boolean = true;

    ret += "success:";
    if (this.success == null) {
      ret += "null";
    } else {
      ret += this.success;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "systemException:";
    if (this.systemException == null) {
      ret += "null";
    } else {
      ret += this.systemException;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class GetFileCount_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("GetFileCount_args");
  private static const ID_FIELD_DESC:TField = new TField("id", TType.STRUCT, 1);
  private static const FOLDER_FIELD_DESC:TField = new TField("folder", TType.STRING, 2);

  private var _id:TaskID;
  public static const ID:int = 1;
  private var _folder:String;
  public static const FOLDER:int = 2;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[ID] = new FieldMetaData("id", TFieldRequirementType.DEFAULT, 
        new StructMetaData(TType.STRUCT, TaskID));
    metaDataMap[FOLDER] = new FieldMetaData("folder", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
  }
  {
    FieldMetaData.addStructMetaDataMap(GetFileCount_args, metaDataMap);
  }

  public function GetFileCount_args() {
  }

  public function get id():TaskID {
    return this._id;
  }

  public function set id(id:TaskID):void {
    this._id = id;
  }

  public function unsetId():void {
    this.id = null;
  }

  // Returns true if field id is set (has been assigned a value) and false otherwise
  public function isSetId():Boolean {
    return this.id != null;
  }

  public function get folder():String {
    return this._folder;
  }

  public function set folder(folder:String):void {
    this._folder = folder;
  }

  public function unsetFolder():void {
    this.folder = null;
  }

  // Returns true if field folder is set (has been assigned a value) and false otherwise
  public function isSetFolder():Boolean {
    return this.folder != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case ID:
      if (value == null) {
        unsetId();
      } else {
        this.id = value;
      }
      break;

    case FOLDER:
      if (value == null) {
        unsetFolder();
      } else {
        this.folder = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case ID:
      return this.id;
    case FOLDER:
      return this.folder;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case ID:
      return isSetId();
    case FOLDER:
      return isSetFolder();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case ID:
          if (field.type == TType.STRUCT) {
            this.id = new TaskID();
            this.id.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case FOLDER:
          if (field.type == TType.STRING) {
            this.folder = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    if (this.id != null) {
      oprot.writeFieldBegin(ID_FIELD_DESC);
      this.id.write(oprot);
      oprot.writeFieldEnd();
    }
    if (this.folder != null) {
      oprot.writeFieldBegin(FOLDER_FIELD_DESC);
      oprot.writeString(this.folder);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("GetFileCount_args(");
    var first:Boolean = true;

    ret += "id:";
    if (this.id == null) {
      ret += "null";
    } else {
      ret += this.id;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "folder:";
    if (this.folder == null) {
      ret += "null";
    } else {
      ret += this.folder;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class GetFileCount_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("GetFileCount_result");
  private static const SUCCESS_FIELD_DESC:TField = new TField("success", TType.I32, 0);
  private static const SYSTEM_EXCEPTION_FIELD_DESC:TField = new TField("systemException", TType.STRUCT, 1);

  private var _success:int;
  public static const SUCCESS:int = 0;
  private var _systemException:SystemException;
  public static const SYSTEMEXCEPTION:int = 1;

  private var __isset_success:Boolean = false;

  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[SUCCESS] = new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.I32));
    metaDataMap[SYSTEMEXCEPTION] = new FieldMetaData("systemException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
  }
  {
    FieldMetaData.addStructMetaDataMap(GetFileCount_result, metaDataMap);
  }

  public function GetFileCount_result() {
  }

  public function get success():int {
    return this._success;
  }

  public function set success(success:int):void {
    this._success = success;
    this.__isset_success = true;
  }

  public function unsetSuccess():void {
    this.__isset_success = false;
  }

  // Returns true if field success is set (has been assigned a value) and false otherwise
  public function isSetSuccess():Boolean {
    return this.__isset_success;
  }

  public function get systemException():SystemException {
    return this._systemException;
  }

  public function set systemException(systemException:SystemException):void {
    this._systemException = systemException;
  }

  public function unsetSystemException():void {
    this.systemException = null;
  }

  // Returns true if field systemException is set (has been assigned a value) and false otherwise
  public function isSetSystemException():Boolean {
    return this.systemException != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case SUCCESS:
      if (value == null) {
        unsetSuccess();
      } else {
        this.success = value;
      }
      break;

    case SYSTEMEXCEPTION:
      if (value == null) {
        unsetSystemException();
      } else {
        this.systemException = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case SUCCESS:
      return this.success;
    case SYSTEMEXCEPTION:
      return this.systemException;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case SUCCESS:
      return isSetSuccess();
    case SYSTEMEXCEPTION:
      return isSetSystemException();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case SUCCESS:
          if (field.type == TType.I32) {
            this.success = iprot.readI32();
            this.__isset_success = true;
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SYSTEMEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.systemException = new SystemException();
            this.systemException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
      oprot.writeI32(this.success);
      oprot.writeFieldEnd();
    } else if (this.isSetSystemException()) {
      oprot.writeFieldBegin(SYSTEM_EXCEPTION_FIELD_DESC);
      this.systemException.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("GetFileCount_result(");
    var first:Boolean = true;

    ret += "success:";
    ret += this.success;
    first = false;
    if (!first) ret +=  ", ";
    ret += "systemException:";
    if (this.systemException == null) {
      ret += "null";
    } else {
      ret += this.systemException;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class GetFiles_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("GetFiles_args");
  private static const ID_FIELD_DESC:TField = new TField("id", TType.STRUCT, 1);
  private static const FOLDER_FIELD_DESC:TField = new TField("folder", TType.STRING, 2);

  private var _id:TaskID;
  public static const ID:int = 1;
  private var _folder:String;
  public static const FOLDER:int = 2;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[ID] = new FieldMetaData("id", TFieldRequirementType.DEFAULT, 
        new StructMetaData(TType.STRUCT, TaskID));
    metaDataMap[FOLDER] = new FieldMetaData("folder", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
  }
  {
    FieldMetaData.addStructMetaDataMap(GetFiles_args, metaDataMap);
  }

  public function GetFiles_args() {
  }

  public function get id():TaskID {
    return this._id;
  }

  public function set id(id:TaskID):void {
    this._id = id;
  }

  public function unsetId():void {
    this.id = null;
  }

  // Returns true if field id is set (has been assigned a value) and false otherwise
  public function isSetId():Boolean {
    return this.id != null;
  }

  public function get folder():String {
    return this._folder;
  }

  public function set folder(folder:String):void {
    this._folder = folder;
  }

  public function unsetFolder():void {
    this.folder = null;
  }

  // Returns true if field folder is set (has been assigned a value) and false otherwise
  public function isSetFolder():Boolean {
    return this.folder != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case ID:
      if (value == null) {
        unsetId();
      } else {
        this.id = value;
      }
      break;

    case FOLDER:
      if (value == null) {
        unsetFolder();
      } else {
        this.folder = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case ID:
      return this.id;
    case FOLDER:
      return this.folder;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case ID:
      return isSetId();
    case FOLDER:
      return isSetFolder();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case ID:
          if (field.type == TType.STRUCT) {
            this.id = new TaskID();
            this.id.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case FOLDER:
          if (field.type == TType.STRING) {
            this.folder = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    if (this.id != null) {
      oprot.writeFieldBegin(ID_FIELD_DESC);
      this.id.write(oprot);
      oprot.writeFieldEnd();
    }
    if (this.folder != null) {
      oprot.writeFieldBegin(FOLDER_FIELD_DESC);
      oprot.writeString(this.folder);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("GetFiles_args(");
    var first:Boolean = true;

    ret += "id:";
    if (this.id == null) {
      ret += "null";
    } else {
      ret += this.id;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "folder:";
    if (this.folder == null) {
      ret += "null";
    } else {
      ret += this.folder;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class GetFiles_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("GetFiles_result");
  private static const SUCCESS_FIELD_DESC:TField = new TField("success", TType.LIST, 0);
  private static const SYSTEM_EXCEPTION_FIELD_DESC:TField = new TField("systemException", TType.STRUCT, 1);

  private var _success:Array;
  public static const SUCCESS:int = 0;
  private var _systemException:SystemException;
  public static const SYSTEMEXCEPTION:int = 1;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[SUCCESS] = new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
        new ListMetaData(TType.LIST, 
            new FieldValueMetaData(TType.STRING)));
    metaDataMap[SYSTEMEXCEPTION] = new FieldMetaData("systemException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
  }
  {
    FieldMetaData.addStructMetaDataMap(GetFiles_result, metaDataMap);
  }

  public function GetFiles_result() {
  }

  public function get success():Array {
    return this._success;
  }

  public function set success(success:Array):void {
    this._success = success;
  }

  public function unsetSuccess():void {
    this.success = null;
  }

  // Returns true if field success is set (has been assigned a value) and false otherwise
  public function isSetSuccess():Boolean {
    return this.success != null;
  }

  public function get systemException():SystemException {
    return this._systemException;
  }

  public function set systemException(systemException:SystemException):void {
    this._systemException = systemException;
  }

  public function unsetSystemException():void {
    this.systemException = null;
  }

  // Returns true if field systemException is set (has been assigned a value) and false otherwise
  public function isSetSystemException():Boolean {
    return this.systemException != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case SUCCESS:
      if (value == null) {
        unsetSuccess();
      } else {
        this.success = value;
      }
      break;

    case SYSTEMEXCEPTION:
      if (value == null) {
        unsetSystemException();
      } else {
        this.systemException = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case SUCCESS:
      return this.success;
    case SYSTEMEXCEPTION:
      return this.systemException;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case SUCCESS:
      return isSetSuccess();
    case SYSTEMEXCEPTION:
      return isSetSystemException();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case SUCCESS:
          if (field.type == TType.LIST) {
            {
              var _list85:TList = iprot.readListBegin();
              this.success = new Array();
              for (var _i86:int = 0; _i86 < _list85.size; ++_i86)
              {
                var _elem87:String;
                _elem87 = iprot.readString();
                this.success.push(_elem87);
              }
              iprot.readListEnd();
            }
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SYSTEMEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.systemException = new SystemException();
            this.systemException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRING, this.success.length));
        for each (var elem88:* in this.success)        {
          oprot.writeString(elem88);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    } else if (this.isSetSystemException()) {
      oprot.writeFieldBegin(SYSTEM_EXCEPTION_FIELD_DESC);
      this.systemException.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("GetFiles_result(");
    var first:Boolean = true;

    ret += "success:";
    if (this.success == null) {
      ret += "null";
    } else {
      ret += this.success;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "systemException:";
    if (this.systemException == null) {
      ret += "null";
    } else {
      ret += this.systemException;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class GetFolders_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("GetFolders_args");
  private static const ID_FIELD_DESC:TField = new TField("id", TType.STRUCT, 1);

  private var _id:TaskID;
  public static const ID:int = 1;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[ID] = new FieldMetaData("id", TFieldRequirementType.DEFAULT, 
        new StructMetaData(TType.STRUCT, TaskID));
  }
  {
    FieldMetaData.addStructMetaDataMap(GetFolders_args, metaDataMap);
  }

  public function GetFolders_args() {
  }

  public function get id():TaskID {
    return this._id;
  }

  public function set id(id:TaskID):void {
    this._id = id;
  }

  public function unsetId():void {
    this.id = null;
  }

  // Returns true if field id is set (has been assigned a value) and false otherwise
  public function isSetId():Boolean {
    return this.id != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case ID:
      if (value == null) {
        unsetId();
      } else {
        this.id = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case ID:
      return this.id;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case ID:
      return isSetId();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case ID:
          if (field.type == TType.STRUCT) {
            this.id = new TaskID();
            this.id.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    if (this.id != null) {
      oprot.writeFieldBegin(ID_FIELD_DESC);
      this.id.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("GetFolders_args(");
    var first:Boolean = true;

    ret += "id:";
    if (this.id == null) {
      ret += "null";
    } else {
      ret += this.id;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class GetFolders_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("GetFolders_result");
  private static const SUCCESS_FIELD_DESC:TField = new TField("success", TType.LIST, 0);
  private static const SYSTEM_EXCEPTION_FIELD_DESC:TField = new TField("systemException", TType.STRUCT, 1);

  private var _success:Array;
  public static const SUCCESS:int = 0;
  private var _systemException:SystemException;
  public static const SYSTEMEXCEPTION:int = 1;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[SUCCESS] = new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
        new ListMetaData(TType.LIST, 
            new FieldValueMetaData(TType.STRING)));
    metaDataMap[SYSTEMEXCEPTION] = new FieldMetaData("systemException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
  }
  {
    FieldMetaData.addStructMetaDataMap(GetFolders_result, metaDataMap);
  }

  public function GetFolders_result() {
  }

  public function get success():Array {
    return this._success;
  }

  public function set success(success:Array):void {
    this._success = success;
  }

  public function unsetSuccess():void {
    this.success = null;
  }

  // Returns true if field success is set (has been assigned a value) and false otherwise
  public function isSetSuccess():Boolean {
    return this.success != null;
  }

  public function get systemException():SystemException {
    return this._systemException;
  }

  public function set systemException(systemException:SystemException):void {
    this._systemException = systemException;
  }

  public function unsetSystemException():void {
    this.systemException = null;
  }

  // Returns true if field systemException is set (has been assigned a value) and false otherwise
  public function isSetSystemException():Boolean {
    return this.systemException != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case SUCCESS:
      if (value == null) {
        unsetSuccess();
      } else {
        this.success = value;
      }
      break;

    case SYSTEMEXCEPTION:
      if (value == null) {
        unsetSystemException();
      } else {
        this.systemException = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case SUCCESS:
      return this.success;
    case SYSTEMEXCEPTION:
      return this.systemException;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case SUCCESS:
      return isSetSuccess();
    case SYSTEMEXCEPTION:
      return isSetSystemException();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case SUCCESS:
          if (field.type == TType.LIST) {
            {
              var _list92:TList = iprot.readListBegin();
              this.success = new Array();
              for (var _i93:int = 0; _i93 < _list92.size; ++_i93)
              {
                var _elem94:String;
                _elem94 = iprot.readString();
                this.success.push(_elem94);
              }
              iprot.readListEnd();
            }
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SYSTEMEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.systemException = new SystemException();
            this.systemException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRING, this.success.length));
        for each (var elem95:* in this.success)        {
          oprot.writeString(elem95);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    } else if (this.isSetSystemException()) {
      oprot.writeFieldBegin(SYSTEM_EXCEPTION_FIELD_DESC);
      this.systemException.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("GetFolders_result(");
    var first:Boolean = true;

    ret += "success:";
    if (this.success == null) {
      ret += "null";
    } else {
      ret += this.success;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "systemException:";
    if (this.systemException == null) {
      ret += "null";
    } else {
      ret += this.systemException;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class GetState_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("GetState_args");
  private static const ID_FIELD_DESC:TField = new TField("id", TType.STRUCT, 1);

  private var _id:TaskID;
  public static const ID:int = 1;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[ID] = new FieldMetaData("id", TFieldRequirementType.DEFAULT, 
        new StructMetaData(TType.STRUCT, TaskID));
  }
  {
    FieldMetaData.addStructMetaDataMap(GetState_args, metaDataMap);
  }

  public function GetState_args() {
  }

  public function get id():TaskID {
    return this._id;
  }

  public function set id(id:TaskID):void {
    this._id = id;
  }

  public function unsetId():void {
    this.id = null;
  }

  // Returns true if field id is set (has been assigned a value) and false otherwise
  public function isSetId():Boolean {
    return this.id != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case ID:
      if (value == null) {
        unsetId();
      } else {
        this.id = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case ID:
      return this.id;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case ID:
      return isSetId();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case ID:
          if (field.type == TType.STRUCT) {
            this.id = new TaskID();
            this.id.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    if (this.id != null) {
      oprot.writeFieldBegin(ID_FIELD_DESC);
      this.id.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("GetState_args(");
    var first:Boolean = true;

    ret += "id:";
    if (this.id == null) {
      ret += "null";
    } else {
      ret += this.id;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class GetState_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("GetState_result");
  private static const SUCCESS_FIELD_DESC:TField = new TField("success", TType.STRUCT, 0);
  private static const SYSTEM_EXCEPTION_FIELD_DESC:TField = new TField("systemException", TType.STRUCT, 1);

  private var _success:URTaskState;
  public static const SUCCESS:int = 0;
  private var _systemException:SystemException;
  public static const SYSTEMEXCEPTION:int = 1;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[SUCCESS] = new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
        new StructMetaData(TType.STRUCT, URTaskState));
    metaDataMap[SYSTEMEXCEPTION] = new FieldMetaData("systemException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
  }
  {
    FieldMetaData.addStructMetaDataMap(GetState_result, metaDataMap);
  }

  public function GetState_result() {
  }

  public function get success():URTaskState {
    return this._success;
  }

  public function set success(success:URTaskState):void {
    this._success = success;
  }

  public function unsetSuccess():void {
    this.success = null;
  }

  // Returns true if field success is set (has been assigned a value) and false otherwise
  public function isSetSuccess():Boolean {
    return this.success != null;
  }

  public function get systemException():SystemException {
    return this._systemException;
  }

  public function set systemException(systemException:SystemException):void {
    this._systemException = systemException;
  }

  public function unsetSystemException():void {
    this.systemException = null;
  }

  // Returns true if field systemException is set (has been assigned a value) and false otherwise
  public function isSetSystemException():Boolean {
    return this.systemException != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case SUCCESS:
      if (value == null) {
        unsetSuccess();
      } else {
        this.success = value;
      }
      break;

    case SYSTEMEXCEPTION:
      if (value == null) {
        unsetSystemException();
      } else {
        this.systemException = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case SUCCESS:
      return this.success;
    case SYSTEMEXCEPTION:
      return this.systemException;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case SUCCESS:
      return isSetSuccess();
    case SYSTEMEXCEPTION:
      return isSetSystemException();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new URTaskState();
            this.success.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SYSTEMEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.systemException = new SystemException();
            this.systemException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetSystemException()) {
      oprot.writeFieldBegin(SYSTEM_EXCEPTION_FIELD_DESC);
      this.systemException.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("GetState_result(");
    var first:Boolean = true;

    ret += "success:";
    if (this.success == null) {
      ret += "null";
    } else {
      ret += this.success;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "systemException:";
    if (this.systemException == null) {
      ret += "null";
    } else {
      ret += this.systemException;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class GetWatchedFolders_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("GetWatchedFolders_args");
  private static const ID_FIELD_DESC:TField = new TField("id", TType.STRUCT, 1);

  private var _id:TaskID;
  public static const ID:int = 1;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[ID] = new FieldMetaData("id", TFieldRequirementType.DEFAULT, 
        new StructMetaData(TType.STRUCT, TaskID));
  }
  {
    FieldMetaData.addStructMetaDataMap(GetWatchedFolders_args, metaDataMap);
  }

  public function GetWatchedFolders_args() {
  }

  public function get id():TaskID {
    return this._id;
  }

  public function set id(id:TaskID):void {
    this._id = id;
  }

  public function unsetId():void {
    this.id = null;
  }

  // Returns true if field id is set (has been assigned a value) and false otherwise
  public function isSetId():Boolean {
    return this.id != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case ID:
      if (value == null) {
        unsetId();
      } else {
        this.id = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case ID:
      return this.id;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case ID:
      return isSetId();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case ID:
          if (field.type == TType.STRUCT) {
            this.id = new TaskID();
            this.id.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    if (this.id != null) {
      oprot.writeFieldBegin(ID_FIELD_DESC);
      this.id.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("GetWatchedFolders_args(");
    var first:Boolean = true;

    ret += "id:";
    if (this.id == null) {
      ret += "null";
    } else {
      ret += this.id;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class GetWatchedFolders_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("GetWatchedFolders_result");
  private static const SUCCESS_FIELD_DESC:TField = new TField("success", TType.LIST, 0);
  private static const SYSTEM_EXCEPTION_FIELD_DESC:TField = new TField("systemException", TType.STRUCT, 1);

  private var _success:Array;
  public static const SUCCESS:int = 0;
  private var _systemException:SystemException;
  public static const SYSTEMEXCEPTION:int = 1;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[SUCCESS] = new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
        new ListMetaData(TType.LIST, 
            new FieldValueMetaData(TType.STRING)));
    metaDataMap[SYSTEMEXCEPTION] = new FieldMetaData("systemException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
  }
  {
    FieldMetaData.addStructMetaDataMap(GetWatchedFolders_result, metaDataMap);
  }

  public function GetWatchedFolders_result() {
  }

  public function get success():Array {
    return this._success;
  }

  public function set success(success:Array):void {
    this._success = success;
  }

  public function unsetSuccess():void {
    this.success = null;
  }

  // Returns true if field success is set (has been assigned a value) and false otherwise
  public function isSetSuccess():Boolean {
    return this.success != null;
  }

  public function get systemException():SystemException {
    return this._systemException;
  }

  public function set systemException(systemException:SystemException):void {
    this._systemException = systemException;
  }

  public function unsetSystemException():void {
    this.systemException = null;
  }

  // Returns true if field systemException is set (has been assigned a value) and false otherwise
  public function isSetSystemException():Boolean {
    return this.systemException != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case SUCCESS:
      if (value == null) {
        unsetSuccess();
      } else {
        this.success = value;
      }
      break;

    case SYSTEMEXCEPTION:
      if (value == null) {
        unsetSystemException();
      } else {
        this.systemException = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case SUCCESS:
      return this.success;
    case SYSTEMEXCEPTION:
      return this.systemException;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case SUCCESS:
      return isSetSuccess();
    case SYSTEMEXCEPTION:
      return isSetSystemException();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case SUCCESS:
          if (field.type == TType.LIST) {
            {
              var _list102:TList = iprot.readListBegin();
              this.success = new Array();
              for (var _i103:int = 0; _i103 < _list102.size; ++_i103)
              {
                var _elem104:String;
                _elem104 = iprot.readString();
                this.success.push(_elem104);
              }
              iprot.readListEnd();
            }
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SYSTEMEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.systemException = new SystemException();
            this.systemException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRING, this.success.length));
        for each (var elem105:* in this.success)        {
          oprot.writeString(elem105);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    } else if (this.isSetSystemException()) {
      oprot.writeFieldBegin(SYSTEM_EXCEPTION_FIELD_DESC);
      this.systemException.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("GetWatchedFolders_result(");
    var first:Boolean = true;

    ret += "success:";
    if (this.success == null) {
      ret += "null";
    } else {
      ret += this.success;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "systemException:";
    if (this.systemException == null) {
      ret += "null";
    } else {
      ret += this.systemException;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class ReportFileCount_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("ReportFileCount_args");
  private static const ID_FIELD_DESC:TField = new TField("id", TType.STRUCT, 1);
  private static const FOLDER_FIELD_DESC:TField = new TField("folder", TType.STRING, 2);
  private static const COUNT_FIELD_DESC:TField = new TField("count", TType.I32, 3);

  private var _id:TaskID;
  public static const ID:int = 1;
  private var _folder:String;
  public static const FOLDER:int = 2;
  private var _count:int;
  public static const COUNT:int = 3;

  private var __isset_count:Boolean = false;

  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[ID] = new FieldMetaData("id", TFieldRequirementType.DEFAULT, 
        new StructMetaData(TType.STRUCT, TaskID));
    metaDataMap[FOLDER] = new FieldMetaData("folder", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
    metaDataMap[COUNT] = new FieldMetaData("count", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.I32));
  }
  {
    FieldMetaData.addStructMetaDataMap(ReportFileCount_args, metaDataMap);
  }

  public function ReportFileCount_args() {
  }

  public function get id():TaskID {
    return this._id;
  }

  public function set id(id:TaskID):void {
    this._id = id;
  }

  public function unsetId():void {
    this.id = null;
  }

  // Returns true if field id is set (has been assigned a value) and false otherwise
  public function isSetId():Boolean {
    return this.id != null;
  }

  public function get folder():String {
    return this._folder;
  }

  public function set folder(folder:String):void {
    this._folder = folder;
  }

  public function unsetFolder():void {
    this.folder = null;
  }

  // Returns true if field folder is set (has been assigned a value) and false otherwise
  public function isSetFolder():Boolean {
    return this.folder != null;
  }

  public function get count():int {
    return this._count;
  }

  public function set count(count:int):void {
    this._count = count;
    this.__isset_count = true;
  }

  public function unsetCount():void {
    this.__isset_count = false;
  }

  // Returns true if field count is set (has been assigned a value) and false otherwise
  public function isSetCount():Boolean {
    return this.__isset_count;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case ID:
      if (value == null) {
        unsetId();
      } else {
        this.id = value;
      }
      break;

    case FOLDER:
      if (value == null) {
        unsetFolder();
      } else {
        this.folder = value;
      }
      break;

    case COUNT:
      if (value == null) {
        unsetCount();
      } else {
        this.count = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case ID:
      return this.id;
    case FOLDER:
      return this.folder;
    case COUNT:
      return this.count;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case ID:
      return isSetId();
    case FOLDER:
      return isSetFolder();
    case COUNT:
      return isSetCount();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case ID:
          if (field.type == TType.STRUCT) {
            this.id = new TaskID();
            this.id.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case FOLDER:
          if (field.type == TType.STRING) {
            this.folder = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case COUNT:
          if (field.type == TType.I32) {
            this.count = iprot.readI32();
            this.__isset_count = true;
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    if (this.id != null) {
      oprot.writeFieldBegin(ID_FIELD_DESC);
      this.id.write(oprot);
      oprot.writeFieldEnd();
    }
    if (this.folder != null) {
      oprot.writeFieldBegin(FOLDER_FIELD_DESC);
      oprot.writeString(this.folder);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldBegin(COUNT_FIELD_DESC);
    oprot.writeI32(this.count);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("ReportFileCount_args(");
    var first:Boolean = true;

    ret += "id:";
    if (this.id == null) {
      ret += "null";
    } else {
      ret += this.id;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "folder:";
    if (this.folder == null) {
      ret += "null";
    } else {
      ret += this.folder;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "count:";
    ret += this.count;
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class ReportFileCount_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("ReportFileCount_result");
  private static const SYSTEM_EXCEPTION_FIELD_DESC:TField = new TField("systemException", TType.STRUCT, 1);

  private var _systemException:SystemException;
  public static const SYSTEMEXCEPTION:int = 1;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[SYSTEMEXCEPTION] = new FieldMetaData("systemException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
  }
  {
    FieldMetaData.addStructMetaDataMap(ReportFileCount_result, metaDataMap);
  }

  public function ReportFileCount_result() {
  }

  public function get systemException():SystemException {
    return this._systemException;
  }

  public function set systemException(systemException:SystemException):void {
    this._systemException = systemException;
  }

  public function unsetSystemException():void {
    this.systemException = null;
  }

  // Returns true if field systemException is set (has been assigned a value) and false otherwise
  public function isSetSystemException():Boolean {
    return this.systemException != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case SYSTEMEXCEPTION:
      if (value == null) {
        unsetSystemException();
      } else {
        this.systemException = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case SYSTEMEXCEPTION:
      return this.systemException;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case SYSTEMEXCEPTION:
      return isSetSystemException();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case SYSTEMEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.systemException = new SystemException();
            this.systemException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    if (this.isSetSystemException()) {
      oprot.writeFieldBegin(SYSTEM_EXCEPTION_FIELD_DESC);
      this.systemException.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("ReportFileCount_result(");
    var first:Boolean = true;

    ret += "systemException:";
    if (this.systemException == null) {
      ret += "null";
    } else {
      ret += this.systemException;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class ReportFolderNotFound_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("ReportFolderNotFound_args");
  private static const ID_FIELD_DESC:TField = new TField("id", TType.STRUCT, 1);
  private static const FOLDER_FIELD_DESC:TField = new TField("folder", TType.STRING, 2);

  private var _id:TaskID;
  public static const ID:int = 1;
  private var _folder:String;
  public static const FOLDER:int = 2;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[ID] = new FieldMetaData("id", TFieldRequirementType.DEFAULT, 
        new StructMetaData(TType.STRUCT, TaskID));
    metaDataMap[FOLDER] = new FieldMetaData("folder", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
  }
  {
    FieldMetaData.addStructMetaDataMap(ReportFolderNotFound_args, metaDataMap);
  }

  public function ReportFolderNotFound_args() {
  }

  public function get id():TaskID {
    return this._id;
  }

  public function set id(id:TaskID):void {
    this._id = id;
  }

  public function unsetId():void {
    this.id = null;
  }

  // Returns true if field id is set (has been assigned a value) and false otherwise
  public function isSetId():Boolean {
    return this.id != null;
  }

  public function get folder():String {
    return this._folder;
  }

  public function set folder(folder:String):void {
    this._folder = folder;
  }

  public function unsetFolder():void {
    this.folder = null;
  }

  // Returns true if field folder is set (has been assigned a value) and false otherwise
  public function isSetFolder():Boolean {
    return this.folder != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case ID:
      if (value == null) {
        unsetId();
      } else {
        this.id = value;
      }
      break;

    case FOLDER:
      if (value == null) {
        unsetFolder();
      } else {
        this.folder = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case ID:
      return this.id;
    case FOLDER:
      return this.folder;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case ID:
      return isSetId();
    case FOLDER:
      return isSetFolder();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case ID:
          if (field.type == TType.STRUCT) {
            this.id = new TaskID();
            this.id.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case FOLDER:
          if (field.type == TType.STRING) {
            this.folder = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    if (this.id != null) {
      oprot.writeFieldBegin(ID_FIELD_DESC);
      this.id.write(oprot);
      oprot.writeFieldEnd();
    }
    if (this.folder != null) {
      oprot.writeFieldBegin(FOLDER_FIELD_DESC);
      oprot.writeString(this.folder);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("ReportFolderNotFound_args(");
    var first:Boolean = true;

    ret += "id:";
    if (this.id == null) {
      ret += "null";
    } else {
      ret += this.id;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "folder:";
    if (this.folder == null) {
      ret += "null";
    } else {
      ret += this.folder;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class ReportFolderNotFound_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("ReportFolderNotFound_result");
  private static const SYSTEM_EXCEPTION_FIELD_DESC:TField = new TField("systemException", TType.STRUCT, 1);

  private var _systemException:SystemException;
  public static const SYSTEMEXCEPTION:int = 1;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[SYSTEMEXCEPTION] = new FieldMetaData("systemException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
  }
  {
    FieldMetaData.addStructMetaDataMap(ReportFolderNotFound_result, metaDataMap);
  }

  public function ReportFolderNotFound_result() {
  }

  public function get systemException():SystemException {
    return this._systemException;
  }

  public function set systemException(systemException:SystemException):void {
    this._systemException = systemException;
  }

  public function unsetSystemException():void {
    this.systemException = null;
  }

  // Returns true if field systemException is set (has been assigned a value) and false otherwise
  public function isSetSystemException():Boolean {
    return this.systemException != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case SYSTEMEXCEPTION:
      if (value == null) {
        unsetSystemException();
      } else {
        this.systemException = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case SYSTEMEXCEPTION:
      return this.systemException;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case SYSTEMEXCEPTION:
      return isSetSystemException();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case SYSTEMEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.systemException = new SystemException();
            this.systemException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    if (this.isSetSystemException()) {
      oprot.writeFieldBegin(SYSTEM_EXCEPTION_FIELD_DESC);
      this.systemException.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("ReportFolderNotFound_result(");
    var first:Boolean = true;

    ret += "systemException:";
    if (this.systemException == null) {
      ret += "null";
    } else {
      ret += this.systemException;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class ReportFolderUploadComplete_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("ReportFolderUploadComplete_args");
  private static const ID_FIELD_DESC:TField = new TField("id", TType.STRUCT, 1);
  private static const FOLDER_FIELD_DESC:TField = new TField("folder", TType.STRING, 2);

  private var _id:TaskID;
  public static const ID:int = 1;
  private var _folder:String;
  public static const FOLDER:int = 2;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[ID] = new FieldMetaData("id", TFieldRequirementType.DEFAULT, 
        new StructMetaData(TType.STRUCT, TaskID));
    metaDataMap[FOLDER] = new FieldMetaData("folder", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
  }
  {
    FieldMetaData.addStructMetaDataMap(ReportFolderUploadComplete_args, metaDataMap);
  }

  public function ReportFolderUploadComplete_args() {
  }

  public function get id():TaskID {
    return this._id;
  }

  public function set id(id:TaskID):void {
    this._id = id;
  }

  public function unsetId():void {
    this.id = null;
  }

  // Returns true if field id is set (has been assigned a value) and false otherwise
  public function isSetId():Boolean {
    return this.id != null;
  }

  public function get folder():String {
    return this._folder;
  }

  public function set folder(folder:String):void {
    this._folder = folder;
  }

  public function unsetFolder():void {
    this.folder = null;
  }

  // Returns true if field folder is set (has been assigned a value) and false otherwise
  public function isSetFolder():Boolean {
    return this.folder != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case ID:
      if (value == null) {
        unsetId();
      } else {
        this.id = value;
      }
      break;

    case FOLDER:
      if (value == null) {
        unsetFolder();
      } else {
        this.folder = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case ID:
      return this.id;
    case FOLDER:
      return this.folder;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case ID:
      return isSetId();
    case FOLDER:
      return isSetFolder();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case ID:
          if (field.type == TType.STRUCT) {
            this.id = new TaskID();
            this.id.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case FOLDER:
          if (field.type == TType.STRING) {
            this.folder = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    if (this.id != null) {
      oprot.writeFieldBegin(ID_FIELD_DESC);
      this.id.write(oprot);
      oprot.writeFieldEnd();
    }
    if (this.folder != null) {
      oprot.writeFieldBegin(FOLDER_FIELD_DESC);
      oprot.writeString(this.folder);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("ReportFolderUploadComplete_args(");
    var first:Boolean = true;

    ret += "id:";
    if (this.id == null) {
      ret += "null";
    } else {
      ret += this.id;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "folder:";
    if (this.folder == null) {
      ret += "null";
    } else {
      ret += this.folder;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class ReportFolderUploadComplete_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("ReportFolderUploadComplete_result");
  private static const SYSTEM_EXCEPTION_FIELD_DESC:TField = new TField("systemException", TType.STRUCT, 1);

  private var _systemException:SystemException;
  public static const SYSTEMEXCEPTION:int = 1;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[SYSTEMEXCEPTION] = new FieldMetaData("systemException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
  }
  {
    FieldMetaData.addStructMetaDataMap(ReportFolderUploadComplete_result, metaDataMap);
  }

  public function ReportFolderUploadComplete_result() {
  }

  public function get systemException():SystemException {
    return this._systemException;
  }

  public function set systemException(systemException:SystemException):void {
    this._systemException = systemException;
  }

  public function unsetSystemException():void {
    this.systemException = null;
  }

  // Returns true if field systemException is set (has been assigned a value) and false otherwise
  public function isSetSystemException():Boolean {
    return this.systemException != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case SYSTEMEXCEPTION:
      if (value == null) {
        unsetSystemException();
      } else {
        this.systemException = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case SYSTEMEXCEPTION:
      return this.systemException;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case SYSTEMEXCEPTION:
      return isSetSystemException();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case SYSTEMEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.systemException = new SystemException();
            this.systemException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    if (this.isSetSystemException()) {
      oprot.writeFieldBegin(SYSTEM_EXCEPTION_FIELD_DESC);
      this.systemException.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("ReportFolderUploadComplete_result(");
    var first:Boolean = true;

    ret += "systemException:";
    if (this.systemException == null) {
      ret += "null";
    } else {
      ret += this.systemException;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class ReportUploadFailed_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("ReportUploadFailed_args");
  private static const ID_FIELD_DESC:TField = new TField("id", TType.STRUCT, 1);
  private static const FOLDER_FIELD_DESC:TField = new TField("folder", TType.STRING, 2);
  private static const PATH_FIELD_DESC:TField = new TField("path", TType.STRING, 3);

  private var _id:TaskID;
  public static const ID:int = 1;
  private var _folder:String;
  public static const FOLDER:int = 2;
  private var _path:String;
  public static const PATH:int = 3;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[ID] = new FieldMetaData("id", TFieldRequirementType.DEFAULT, 
        new StructMetaData(TType.STRUCT, TaskID));
    metaDataMap[FOLDER] = new FieldMetaData("folder", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
    metaDataMap[PATH] = new FieldMetaData("path", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
  }
  {
    FieldMetaData.addStructMetaDataMap(ReportUploadFailed_args, metaDataMap);
  }

  public function ReportUploadFailed_args() {
  }

  public function get id():TaskID {
    return this._id;
  }

  public function set id(id:TaskID):void {
    this._id = id;
  }

  public function unsetId():void {
    this.id = null;
  }

  // Returns true if field id is set (has been assigned a value) and false otherwise
  public function isSetId():Boolean {
    return this.id != null;
  }

  public function get folder():String {
    return this._folder;
  }

  public function set folder(folder:String):void {
    this._folder = folder;
  }

  public function unsetFolder():void {
    this.folder = null;
  }

  // Returns true if field folder is set (has been assigned a value) and false otherwise
  public function isSetFolder():Boolean {
    return this.folder != null;
  }

  public function get path():String {
    return this._path;
  }

  public function set path(path:String):void {
    this._path = path;
  }

  public function unsetPath():void {
    this.path = null;
  }

  // Returns true if field path is set (has been assigned a value) and false otherwise
  public function isSetPath():Boolean {
    return this.path != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case ID:
      if (value == null) {
        unsetId();
      } else {
        this.id = value;
      }
      break;

    case FOLDER:
      if (value == null) {
        unsetFolder();
      } else {
        this.folder = value;
      }
      break;

    case PATH:
      if (value == null) {
        unsetPath();
      } else {
        this.path = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case ID:
      return this.id;
    case FOLDER:
      return this.folder;
    case PATH:
      return this.path;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case ID:
      return isSetId();
    case FOLDER:
      return isSetFolder();
    case PATH:
      return isSetPath();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case ID:
          if (field.type == TType.STRUCT) {
            this.id = new TaskID();
            this.id.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case FOLDER:
          if (field.type == TType.STRING) {
            this.folder = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case PATH:
          if (field.type == TType.STRING) {
            this.path = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    if (this.id != null) {
      oprot.writeFieldBegin(ID_FIELD_DESC);
      this.id.write(oprot);
      oprot.writeFieldEnd();
    }
    if (this.folder != null) {
      oprot.writeFieldBegin(FOLDER_FIELD_DESC);
      oprot.writeString(this.folder);
      oprot.writeFieldEnd();
    }
    if (this.path != null) {
      oprot.writeFieldBegin(PATH_FIELD_DESC);
      oprot.writeString(this.path);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("ReportUploadFailed_args(");
    var first:Boolean = true;

    ret += "id:";
    if (this.id == null) {
      ret += "null";
    } else {
      ret += this.id;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "folder:";
    if (this.folder == null) {
      ret += "null";
    } else {
      ret += this.folder;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "path:";
    if (this.path == null) {
      ret += "null";
    } else {
      ret += this.path;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class ReportUploadFailed_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("ReportUploadFailed_result");
  private static const SYSTEM_EXCEPTION_FIELD_DESC:TField = new TField("systemException", TType.STRUCT, 1);

  private var _systemException:SystemException;
  public static const SYSTEMEXCEPTION:int = 1;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[SYSTEMEXCEPTION] = new FieldMetaData("systemException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
  }
  {
    FieldMetaData.addStructMetaDataMap(ReportUploadFailed_result, metaDataMap);
  }

  public function ReportUploadFailed_result() {
  }

  public function get systemException():SystemException {
    return this._systemException;
  }

  public function set systemException(systemException:SystemException):void {
    this._systemException = systemException;
  }

  public function unsetSystemException():void {
    this.systemException = null;
  }

  // Returns true if field systemException is set (has been assigned a value) and false otherwise
  public function isSetSystemException():Boolean {
    return this.systemException != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case SYSTEMEXCEPTION:
      if (value == null) {
        unsetSystemException();
      } else {
        this.systemException = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case SYSTEMEXCEPTION:
      return this.systemException;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case SYSTEMEXCEPTION:
      return isSetSystemException();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case SYSTEMEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.systemException = new SystemException();
            this.systemException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    if (this.isSetSystemException()) {
      oprot.writeFieldBegin(SYSTEM_EXCEPTION_FIELD_DESC);
      this.systemException.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("ReportUploadFailed_result(");
    var first:Boolean = true;

    ret += "systemException:";
    if (this.systemException == null) {
      ret += "null";
    } else {
      ret += this.systemException;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class UploadFile_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("UploadFile_args");
  private static const ID_FIELD_DESC:TField = new TField("id", TType.STRUCT, 1);
  private static const PATH_FIELD_DESC:TField = new TField("path", TType.STRING, 2);
  private static const DATA_FIELD_DESC:TField = new TField("data", TType.STRING, 3);
  private static const INFO_FIELD_DESC:TField = new TField("info", TType.STRUCT, 4);

  private var _id:TaskID;
  public static const ID:int = 1;
  private var _path:String;
  public static const PATH:int = 2;
  private var _data:ByteArray;
  public static const DATA:int = 3;
  private var _info:UploadInfo;
  public static const INFO:int = 4;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[ID] = new FieldMetaData("id", TFieldRequirementType.DEFAULT, 
        new StructMetaData(TType.STRUCT, TaskID));
    metaDataMap[PATH] = new FieldMetaData("path", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
    metaDataMap[DATA] = new FieldMetaData("data", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
    metaDataMap[INFO] = new FieldMetaData("info", TFieldRequirementType.DEFAULT, 
        new StructMetaData(TType.STRUCT, UploadInfo));
  }
  {
    FieldMetaData.addStructMetaDataMap(UploadFile_args, metaDataMap);
  }

  public function UploadFile_args() {
  }

  public function get id():TaskID {
    return this._id;
  }

  public function set id(id:TaskID):void {
    this._id = id;
  }

  public function unsetId():void {
    this.id = null;
  }

  // Returns true if field id is set (has been assigned a value) and false otherwise
  public function isSetId():Boolean {
    return this.id != null;
  }

  public function get path():String {
    return this._path;
  }

  public function set path(path:String):void {
    this._path = path;
  }

  public function unsetPath():void {
    this.path = null;
  }

  // Returns true if field path is set (has been assigned a value) and false otherwise
  public function isSetPath():Boolean {
    return this.path != null;
  }

  public function get data():ByteArray {
    return this._data;
  }

  public function set data(data:ByteArray):void {
    this._data = data;
  }

  public function unsetData():void {
    this.data = null;
  }

  // Returns true if field data is set (has been assigned a value) and false otherwise
  public function isSetData():Boolean {
    return this.data != null;
  }

  public function get info():UploadInfo {
    return this._info;
  }

  public function set info(info:UploadInfo):void {
    this._info = info;
  }

  public function unsetInfo():void {
    this.info = null;
  }

  // Returns true if field info is set (has been assigned a value) and false otherwise
  public function isSetInfo():Boolean {
    return this.info != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case ID:
      if (value == null) {
        unsetId();
      } else {
        this.id = value;
      }
      break;

    case PATH:
      if (value == null) {
        unsetPath();
      } else {
        this.path = value;
      }
      break;

    case DATA:
      if (value == null) {
        unsetData();
      } else {
        this.data = value;
      }
      break;

    case INFO:
      if (value == null) {
        unsetInfo();
      } else {
        this.info = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case ID:
      return this.id;
    case PATH:
      return this.path;
    case DATA:
      return this.data;
    case INFO:
      return this.info;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case ID:
      return isSetId();
    case PATH:
      return isSetPath();
    case DATA:
      return isSetData();
    case INFO:
      return isSetInfo();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case ID:
          if (field.type == TType.STRUCT) {
            this.id = new TaskID();
            this.id.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case PATH:
          if (field.type == TType.STRING) {
            this.path = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case DATA:
          if (field.type == TType.STRING) {
            this.data = iprot.readBinary();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case INFO:
          if (field.type == TType.STRUCT) {
            this.info = new UploadInfo();
            this.info.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    if (this.id != null) {
      oprot.writeFieldBegin(ID_FIELD_DESC);
      this.id.write(oprot);
      oprot.writeFieldEnd();
    }
    if (this.path != null) {
      oprot.writeFieldBegin(PATH_FIELD_DESC);
      oprot.writeString(this.path);
      oprot.writeFieldEnd();
    }
    if (this.data != null) {
      oprot.writeFieldBegin(DATA_FIELD_DESC);
      oprot.writeBinary(this.data);
      oprot.writeFieldEnd();
    }
    if (this.info != null) {
      oprot.writeFieldBegin(INFO_FIELD_DESC);
      this.info.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("UploadFile_args(");
    var first:Boolean = true;

    ret += "id:";
    if (this.id == null) {
      ret += "null";
    } else {
      ret += this.id;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "path:";
    if (this.path == null) {
      ret += "null";
    } else {
      ret += this.path;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "data:";
    if (this.data == null) {
      ret += "null";
    } else {
        ret += "BINARY";
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "info:";
    if (this.info == null) {
      ret += "null";
    } else {
      ret += this.info;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class UploadFile_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("UploadFile_result");
  private static const SYSTEM_EXCEPTION_FIELD_DESC:TField = new TField("systemException", TType.STRUCT, 1);

  private var _systemException:SystemException;
  public static const SYSTEMEXCEPTION:int = 1;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[SYSTEMEXCEPTION] = new FieldMetaData("systemException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
  }
  {
    FieldMetaData.addStructMetaDataMap(UploadFile_result, metaDataMap);
  }

  public function UploadFile_result() {
  }

  public function get systemException():SystemException {
    return this._systemException;
  }

  public function set systemException(systemException:SystemException):void {
    this._systemException = systemException;
  }

  public function unsetSystemException():void {
    this.systemException = null;
  }

  // Returns true if field systemException is set (has been assigned a value) and false otherwise
  public function isSetSystemException():Boolean {
    return this.systemException != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case SYSTEMEXCEPTION:
      if (value == null) {
        unsetSystemException();
      } else {
        this.systemException = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case SYSTEMEXCEPTION:
      return this.systemException;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case SYSTEMEXCEPTION:
      return isSetSystemException();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case SYSTEMEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.systemException = new SystemException();
            this.systemException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    if (this.isSetSystemException()) {
      oprot.writeFieldBegin(SYSTEM_EXCEPTION_FIELD_DESC);
      this.systemException.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("UploadFile_result(");
    var first:Boolean = true;

    ret += "systemException:";
    if (this.systemException == null) {
      ret += "null";
    } else {
      ret += this.systemException;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

