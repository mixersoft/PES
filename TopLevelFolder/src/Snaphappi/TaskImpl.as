/**
 * Autogenerated by Thrift Compiler (0.9.0-dev)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
package Snaphappi {

import org.apache.thrift.Set;
import flash.utils.ByteArray;
import flash.utils.Dictionary;
import com.hurlant.math.BigInteger;

import org.apache.thrift.*;
import org.apache.thrift.meta_data.*;
import org.apache.thrift.protocol.*;


  public class TaskImpl implements Task {
    public function TaskImpl(iprot:TProtocol, oprot:TProtocol=null)
    {
      iprot_ = iprot;
      if (oprot == null) {
        oprot_ = iprot;
      } else {
        oprot_ = oprot;
      }    }

    protected var iprot_:TProtocol;
    protected var oprot_:TProtocol;

    protected var seqid_:int;

    public function getInputProtocol():TProtocol
    {
      return this.iprot_;
    }

    public function getOutputProtocol():TProtocol
    {
      return this.oprot_;
    }

    //function onError(Error):void;
    //function onSuccess():void;
    public function AddFolder(id:TaskID, path:String, onError:Function, onSuccess:Function):void
    {
      oprot_.writeMessageBegin(new TMessage("AddFolder", TMessageType.CALL, seqid_));
      var args:AddFolder_args = new AddFolder_args();
      args.id = id;
      args.path = path;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush(function(error:Error):void {
        try {
          if (error != null) {
            if (onError != null) onError(error);
            return;
          }
          var msg:TMessage = iprot_.readMessageBegin();
          if (msg.type == TMessageType.EXCEPTION) {
            var x:TApplicationError = TApplicationError.read(iprot_);
            iprot_.readMessageEnd();
            if (onError != null) onError(x);
            return;
          }
          var result :AddFolder_result = new AddFolder_result();
          result.read(iprot_);
          iprot_.readMessageEnd();
          if (result.systemException != null) {
            if (onError != null) onError(result.systemException);
            return;
          }
          if (onSuccess != null) onSuccess();
          return;
        } catch (e:TError) {
          if (onError != null) onError(e);
        }
      });
    }

    //function onError(Error):void;
    //function onSuccess():void;
    public function RemoveFolder(id:TaskID, path:String, onError:Function, onSuccess:Function):void
    {
      oprot_.writeMessageBegin(new TMessage("RemoveFolder", TMessageType.CALL, seqid_));
      var args:RemoveFolder_args = new RemoveFolder_args();
      args.id = id;
      args.path = path;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush(function(error:Error):void {
        try {
          if (error != null) {
            if (onError != null) onError(error);
            return;
          }
          var msg:TMessage = iprot_.readMessageBegin();
          if (msg.type == TMessageType.EXCEPTION) {
            var x:TApplicationError = TApplicationError.read(iprot_);
            iprot_.readMessageEnd();
            if (onError != null) onError(x);
            return;
          }
          var result :RemoveFolder_result = new RemoveFolder_result();
          result.read(iprot_);
          iprot_.readMessageEnd();
          if (result.systemException != null) {
            if (onError != null) onError(result.systemException);
            return;
          }
          if (onSuccess != null) onSuccess();
          return;
        } catch (e:TError) {
          if (onError != null) onError(e);
        }
      });
    }

    //function onError(Error):void;
    //function onSuccess(String):void;
    public function GetDeviceID(authToken:String, sessionID:String, onError:Function, onSuccess:Function):void
    {
      oprot_.writeMessageBegin(new TMessage("GetDeviceID", TMessageType.CALL, seqid_));
      var args:GetDeviceID_args = new GetDeviceID_args();
      args.authToken = authToken;
      args.sessionID = sessionID;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush(function(error:Error):void {
        try {
          if (error != null) {
            if (onError != null) onError(error);
            return;
          }
          var msg:TMessage = iprot_.readMessageBegin();
          if (msg.type == TMessageType.EXCEPTION) {
            var x:TApplicationError = TApplicationError.read(iprot_);
            iprot_.readMessageEnd();
            if (onError != null) onError(x);
            return;
          }
          var result :GetDeviceID_result = new GetDeviceID_result();
          result.read(iprot_);
          iprot_.readMessageEnd();
          if (result.isSetSuccess()) {
            if (onSuccess != null) onSuccess(result.success);
            return;
          }
          if (result.systemException != null) {
            if (onError != null) onError(result.systemException);
            return;
          }
          if (onError != null) onError(new TApplicationError(TApplicationError.MISSING_RESULT, "GetDeviceID failed: unknown result"));
        } catch (e:TError) {
          if (onError != null) onError(e);
        }
      });
    }

    //function onError(Error):void;
    //function onSuccess(int):void;
    public function GetFileCount(id:TaskID, folder:String, onError:Function, onSuccess:Function):void
    {
      oprot_.writeMessageBegin(new TMessage("GetFileCount", TMessageType.CALL, seqid_));
      var args:GetFileCount_args = new GetFileCount_args();
      args.id = id;
      args.folder = folder;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush(function(error:Error):void {
        try {
          if (error != null) {
            if (onError != null) onError(error);
            return;
          }
          var msg:TMessage = iprot_.readMessageBegin();
          if (msg.type == TMessageType.EXCEPTION) {
            var x:TApplicationError = TApplicationError.read(iprot_);
            iprot_.readMessageEnd();
            if (onError != null) onError(x);
            return;
          }
          var result :GetFileCount_result = new GetFileCount_result();
          result.read(iprot_);
          iprot_.readMessageEnd();
          if (result.isSetSuccess()) {
            if (onSuccess != null) onSuccess(result.success);
            return;
          }
          if (result.systemException != null) {
            if (onError != null) onError(result.systemException);
            return;
          }
          if (onError != null) onError(new TApplicationError(TApplicationError.MISSING_RESULT, "GetFileCount failed: unknown result"));
        } catch (e:TError) {
          if (onError != null) onError(e);
        }
      });
    }

    //function onError(Error):void;
    //function onSuccess(Array):void;
    public function GetFiles(id:TaskID, folder:String, onError:Function, onSuccess:Function):void
    {
      oprot_.writeMessageBegin(new TMessage("GetFiles", TMessageType.CALL, seqid_));
      var args:GetFiles_args = new GetFiles_args();
      args.id = id;
      args.folder = folder;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush(function(error:Error):void {
        try {
          if (error != null) {
            if (onError != null) onError(error);
            return;
          }
          var msg:TMessage = iprot_.readMessageBegin();
          if (msg.type == TMessageType.EXCEPTION) {
            var x:TApplicationError = TApplicationError.read(iprot_);
            iprot_.readMessageEnd();
            if (onError != null) onError(x);
            return;
          }
          var result :GetFiles_result = new GetFiles_result();
          result.read(iprot_);
          iprot_.readMessageEnd();
          if (result.isSetSuccess()) {
            if (onSuccess != null) onSuccess(result.success);
            return;
          }
          if (result.systemException != null) {
            if (onError != null) onError(result.systemException);
            return;
          }
          if (onError != null) onError(new TApplicationError(TApplicationError.MISSING_RESULT, "GetFiles failed: unknown result"));
        } catch (e:TError) {
          if (onError != null) onError(e);
        }
      });
    }

    //function onError(Error):void;
    //function onSuccess(Array):void;
    public function GetFolders(id:TaskID, onError:Function, onSuccess:Function):void
    {
      oprot_.writeMessageBegin(new TMessage("GetFolders", TMessageType.CALL, seqid_));
      var args:GetFolders_args = new GetFolders_args();
      args.id = id;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush(function(error:Error):void {
        try {
          if (error != null) {
            if (onError != null) onError(error);
            return;
          }
          var msg:TMessage = iprot_.readMessageBegin();
          if (msg.type == TMessageType.EXCEPTION) {
            var x:TApplicationError = TApplicationError.read(iprot_);
            iprot_.readMessageEnd();
            if (onError != null) onError(x);
            return;
          }
          var result :GetFolders_result = new GetFolders_result();
          result.read(iprot_);
          iprot_.readMessageEnd();
          if (result.isSetSuccess()) {
            if (onSuccess != null) onSuccess(result.success);
            return;
          }
          if (result.systemException != null) {
            if (onError != null) onError(result.systemException);
            return;
          }
          if (onError != null) onError(new TApplicationError(TApplicationError.MISSING_RESULT, "GetFolders failed: unknown result"));
        } catch (e:TError) {
          if (onError != null) onError(e);
        }
      });
    }

    //function onError(Error):void;
    //function onSuccess(URTaskState):void;
    public function GetState(id:TaskID, onError:Function, onSuccess:Function):void
    {
      oprot_.writeMessageBegin(new TMessage("GetState", TMessageType.CALL, seqid_));
      var args:GetState_args = new GetState_args();
      args.id = id;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush(function(error:Error):void {
        try {
          if (error != null) {
            if (onError != null) onError(error);
            return;
          }
          var msg:TMessage = iprot_.readMessageBegin();
          if (msg.type == TMessageType.EXCEPTION) {
            var x:TApplicationError = TApplicationError.read(iprot_);
            iprot_.readMessageEnd();
            if (onError != null) onError(x);
            return;
          }
          var result :GetState_result = new GetState_result();
          result.read(iprot_);
          iprot_.readMessageEnd();
          if (result.isSetSuccess()) {
            if (onSuccess != null) onSuccess(result.success);
            return;
          }
          if (result.systemException != null) {
            if (onError != null) onError(result.systemException);
            return;
          }
          if (onError != null) onError(new TApplicationError(TApplicationError.MISSING_RESULT, "GetState failed: unknown result"));
        } catch (e:TError) {
          if (onError != null) onError(e);
        }
      });
    }

    //function onError(Error):void;
    //function onSuccess(Array):void;
    public function GetWatchedFolders(id:TaskID, onError:Function, onSuccess:Function):void
    {
      oprot_.writeMessageBegin(new TMessage("GetWatchedFolders", TMessageType.CALL, seqid_));
      var args:GetWatchedFolders_args = new GetWatchedFolders_args();
      args.id = id;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush(function(error:Error):void {
        try {
          if (error != null) {
            if (onError != null) onError(error);
            return;
          }
          var msg:TMessage = iprot_.readMessageBegin();
          if (msg.type == TMessageType.EXCEPTION) {
            var x:TApplicationError = TApplicationError.read(iprot_);
            iprot_.readMessageEnd();
            if (onError != null) onError(x);
            return;
          }
          var result :GetWatchedFolders_result = new GetWatchedFolders_result();
          result.read(iprot_);
          iprot_.readMessageEnd();
          if (result.isSetSuccess()) {
            if (onSuccess != null) onSuccess(result.success);
            return;
          }
          if (result.systemException != null) {
            if (onError != null) onError(result.systemException);
            return;
          }
          if (onError != null) onError(new TApplicationError(TApplicationError.MISSING_RESULT, "GetWatchedFolders failed: unknown result"));
        } catch (e:TError) {
          if (onError != null) onError(e);
        }
      });
    }

    //function onError(Error):void;
    //function onSuccess():void;
    public function ReportFileCount(id:TaskID, folder:String, count:int, onError:Function, onSuccess:Function):void
    {
      oprot_.writeMessageBegin(new TMessage("ReportFileCount", TMessageType.CALL, seqid_));
      var args:ReportFileCount_args = new ReportFileCount_args();
      args.id = id;
      args.folder = folder;
      args.count = count;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush(function(error:Error):void {
        try {
          if (error != null) {
            if (onError != null) onError(error);
            return;
          }
          var msg:TMessage = iprot_.readMessageBegin();
          if (msg.type == TMessageType.EXCEPTION) {
            var x:TApplicationError = TApplicationError.read(iprot_);
            iprot_.readMessageEnd();
            if (onError != null) onError(x);
            return;
          }
          var result :ReportFileCount_result = new ReportFileCount_result();
          result.read(iprot_);
          iprot_.readMessageEnd();
          if (result.systemException != null) {
            if (onError != null) onError(result.systemException);
            return;
          }
          if (onSuccess != null) onSuccess();
          return;
        } catch (e:TError) {
          if (onError != null) onError(e);
        }
      });
    }

    //function onError(Error):void;
    //function onSuccess():void;
    public function ReportFolderNotFound(id:TaskID, folder:String, onError:Function, onSuccess:Function):void
    {
      oprot_.writeMessageBegin(new TMessage("ReportFolderNotFound", TMessageType.CALL, seqid_));
      var args:ReportFolderNotFound_args = new ReportFolderNotFound_args();
      args.id = id;
      args.folder = folder;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush(function(error:Error):void {
        try {
          if (error != null) {
            if (onError != null) onError(error);
            return;
          }
          var msg:TMessage = iprot_.readMessageBegin();
          if (msg.type == TMessageType.EXCEPTION) {
            var x:TApplicationError = TApplicationError.read(iprot_);
            iprot_.readMessageEnd();
            if (onError != null) onError(x);
            return;
          }
          var result :ReportFolderNotFound_result = new ReportFolderNotFound_result();
          result.read(iprot_);
          iprot_.readMessageEnd();
          if (result.systemException != null) {
            if (onError != null) onError(result.systemException);
            return;
          }
          if (onSuccess != null) onSuccess();
          return;
        } catch (e:TError) {
          if (onError != null) onError(e);
        }
      });
    }

    //function onError(Error):void;
    //function onSuccess():void;
    public function ReportFolderUploadComplete(id:TaskID, folder:String, onError:Function, onSuccess:Function):void
    {
      oprot_.writeMessageBegin(new TMessage("ReportFolderUploadComplete", TMessageType.CALL, seqid_));
      var args:ReportFolderUploadComplete_args = new ReportFolderUploadComplete_args();
      args.id = id;
      args.folder = folder;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush(function(error:Error):void {
        try {
          if (error != null) {
            if (onError != null) onError(error);
            return;
          }
          var msg:TMessage = iprot_.readMessageBegin();
          if (msg.type == TMessageType.EXCEPTION) {
            var x:TApplicationError = TApplicationError.read(iprot_);
            iprot_.readMessageEnd();
            if (onError != null) onError(x);
            return;
          }
          var result :ReportFolderUploadComplete_result = new ReportFolderUploadComplete_result();
          result.read(iprot_);
          iprot_.readMessageEnd();
          if (result.systemException != null) {
            if (onError != null) onError(result.systemException);
            return;
          }
          if (onSuccess != null) onSuccess();
          return;
        } catch (e:TError) {
          if (onError != null) onError(e);
        }
      });
    }

    //function onError(Error):void;
    //function onSuccess():void;
    public function ReportUploadFailed(id:TaskID, folder:String, path:String, onError:Function, onSuccess:Function):void
    {
      oprot_.writeMessageBegin(new TMessage("ReportUploadFailed", TMessageType.CALL, seqid_));
      var args:ReportUploadFailed_args = new ReportUploadFailed_args();
      args.id = id;
      args.folder = folder;
      args.path = path;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush(function(error:Error):void {
        try {
          if (error != null) {
            if (onError != null) onError(error);
            return;
          }
          var msg:TMessage = iprot_.readMessageBegin();
          if (msg.type == TMessageType.EXCEPTION) {
            var x:TApplicationError = TApplicationError.read(iprot_);
            iprot_.readMessageEnd();
            if (onError != null) onError(x);
            return;
          }
          var result :ReportUploadFailed_result = new ReportUploadFailed_result();
          result.read(iprot_);
          iprot_.readMessageEnd();
          if (result.systemException != null) {
            if (onError != null) onError(result.systemException);
            return;
          }
          if (onSuccess != null) onSuccess();
          return;
        } catch (e:TError) {
          if (onError != null) onError(e);
        }
      });
    }

    //function onError(Error):void;
    //function onSuccess():void;
    public function UploadFile(id:TaskID, path:String, data:ByteArray, info:UploadInfo, onError:Function, onSuccess:Function):void
    {
      oprot_.writeMessageBegin(new TMessage("UploadFile", TMessageType.CALL, seqid_));
      var args:UploadFile_args = new UploadFile_args();
      args.id = id;
      args.path = path;
      args.data = data;
      args.info = info;
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush(function(error:Error):void {
        try {
          if (error != null) {
            if (onError != null) onError(error);
            return;
          }
          var msg:TMessage = iprot_.readMessageBegin();
          if (msg.type == TMessageType.EXCEPTION) {
            var x:TApplicationError = TApplicationError.read(iprot_);
            iprot_.readMessageEnd();
            if (onError != null) onError(x);
            return;
          }
          var result :UploadFile_result = new UploadFile_result();
          result.read(iprot_);
          iprot_.readMessageEnd();
          if (result.systemException != null) {
            if (onError != null) onError(result.systemException);
            return;
          }
          if (onSuccess != null) onSuccess();
          return;
        } catch (e:TError) {
          if (onError != null) onError(e);
        }
      });
    }

  }
}
import org.apache.thrift.Set;
import flash.utils.ByteArray;
import flash.utils.Dictionary;
import com.hurlant.math.BigInteger;

import org.apache.thrift.*;
import org.apache.thrift.meta_data.*;
import org.apache.thrift.protocol.*;

import Snaphappi.*;
class AddFolder_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("AddFolder_args");
  private static const ID_FIELD_DESC:TField = new TField("id", TType.STRUCT, 1);
  private static const PATH_FIELD_DESC:TField = new TField("path", TType.STRING, 2);

  private var _id:TaskID;
  public static const ID:int = 1;
  private var _path:String;
  public static const PATH:int = 2;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[ID] = new FieldMetaData("id", TFieldRequirementType.DEFAULT, 
        new StructMetaData(TType.STRUCT, TaskID));
    metaDataMap[PATH] = new FieldMetaData("path", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
  }
  {
    FieldMetaData.addStructMetaDataMap(AddFolder_args, metaDataMap);
  }

  public function AddFolder_args() {
  }

  public function get id():TaskID {
    return this._id;
  }

  public function set id(id:TaskID):void {
    this._id = id;
  }

  public function unsetId():void {
    this.id = null;
  }

  // Returns true if field id is set (has been assigned a value) and false otherwise
  public function isSetId():Boolean {
    return this.id != null;
  }

  public function get path():String {
    return this._path;
  }

  public function set path(path:String):void {
    this._path = path;
  }

  public function unsetPath():void {
    this.path = null;
  }

  // Returns true if field path is set (has been assigned a value) and false otherwise
  public function isSetPath():Boolean {
    return this.path != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case ID:
      if (value == null) {
        unsetId();
      } else {
        this.id = value;
      }
      break;

    case PATH:
      if (value == null) {
        unsetPath();
      } else {
        this.path = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case ID:
      return this.id;
    case PATH:
      return this.path;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case ID:
      return isSetId();
    case PATH:
      return isSetPath();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case ID:
          if (field.type == TType.STRUCT) {
            this.id = new TaskID();
            this.id.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case PATH:
          if (field.type == TType.STRING) {
            this.path = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    if (this.id != null) {
      oprot.writeFieldBegin(ID_FIELD_DESC);
      this.id.write(oprot);
      oprot.writeFieldEnd();
    }
    if (this.path != null) {
      oprot.writeFieldBegin(PATH_FIELD_DESC);
      oprot.writeString(this.path);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("AddFolder_args(");
    var first:Boolean = true;

    ret += "id:";
    if (this.id == null) {
      ret += "null";
    } else {
      ret += this.id;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "path:";
    if (this.path == null) {
      ret += "null";
    } else {
      ret += this.path;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class AddFolder_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("AddFolder_result");
  private static const SYSTEM_EXCEPTION_FIELD_DESC:TField = new TField("systemException", TType.STRUCT, 1);

  private var _systemException:SystemException;
  public static const SYSTEMEXCEPTION:int = 1;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[SYSTEMEXCEPTION] = new FieldMetaData("systemException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
  }
  {
    FieldMetaData.addStructMetaDataMap(AddFolder_result, metaDataMap);
  }

  public function AddFolder_result() {
  }

  public function get systemException():SystemException {
    return this._systemException;
  }

  public function set systemException(systemException:SystemException):void {
    this._systemException = systemException;
  }

  public function unsetSystemException():void {
    this.systemException = null;
  }

  // Returns true if field systemException is set (has been assigned a value) and false otherwise
  public function isSetSystemException():Boolean {
    return this.systemException != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case SYSTEMEXCEPTION:
      if (value == null) {
        unsetSystemException();
      } else {
        this.systemException = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case SYSTEMEXCEPTION:
      return this.systemException;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case SYSTEMEXCEPTION:
      return isSetSystemException();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case SYSTEMEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.systemException = new SystemException();
            this.systemException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    if (this.isSetSystemException()) {
      oprot.writeFieldBegin(SYSTEM_EXCEPTION_FIELD_DESC);
      this.systemException.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("AddFolder_result(");
    var first:Boolean = true;

    ret += "systemException:";
    if (this.systemException == null) {
      ret += "null";
    } else {
      ret += this.systemException;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class RemoveFolder_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("RemoveFolder_args");
  private static const ID_FIELD_DESC:TField = new TField("id", TType.STRUCT, 1);
  private static const PATH_FIELD_DESC:TField = new TField("path", TType.STRING, 2);

  private var _id:TaskID;
  public static const ID:int = 1;
  private var _path:String;
  public static const PATH:int = 2;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[ID] = new FieldMetaData("id", TFieldRequirementType.DEFAULT, 
        new StructMetaData(TType.STRUCT, TaskID));
    metaDataMap[PATH] = new FieldMetaData("path", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
  }
  {
    FieldMetaData.addStructMetaDataMap(RemoveFolder_args, metaDataMap);
  }

  public function RemoveFolder_args() {
  }

  public function get id():TaskID {
    return this._id;
  }

  public function set id(id:TaskID):void {
    this._id = id;
  }

  public function unsetId():void {
    this.id = null;
  }

  // Returns true if field id is set (has been assigned a value) and false otherwise
  public function isSetId():Boolean {
    return this.id != null;
  }

  public function get path():String {
    return this._path;
  }

  public function set path(path:String):void {
    this._path = path;
  }

  public function unsetPath():void {
    this.path = null;
  }

  // Returns true if field path is set (has been assigned a value) and false otherwise
  public function isSetPath():Boolean {
    return this.path != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case ID:
      if (value == null) {
        unsetId();
      } else {
        this.id = value;
      }
      break;

    case PATH:
      if (value == null) {
        unsetPath();
      } else {
        this.path = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case ID:
      return this.id;
    case PATH:
      return this.path;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case ID:
      return isSetId();
    case PATH:
      return isSetPath();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case ID:
          if (field.type == TType.STRUCT) {
            this.id = new TaskID();
            this.id.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case PATH:
          if (field.type == TType.STRING) {
            this.path = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    if (this.id != null) {
      oprot.writeFieldBegin(ID_FIELD_DESC);
      this.id.write(oprot);
      oprot.writeFieldEnd();
    }
    if (this.path != null) {
      oprot.writeFieldBegin(PATH_FIELD_DESC);
      oprot.writeString(this.path);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("RemoveFolder_args(");
    var first:Boolean = true;

    ret += "id:";
    if (this.id == null) {
      ret += "null";
    } else {
      ret += this.id;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "path:";
    if (this.path == null) {
      ret += "null";
    } else {
      ret += this.path;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class RemoveFolder_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("RemoveFolder_result");
  private static const SYSTEM_EXCEPTION_FIELD_DESC:TField = new TField("systemException", TType.STRUCT, 1);

  private var _systemException:SystemException;
  public static const SYSTEMEXCEPTION:int = 1;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[SYSTEMEXCEPTION] = new FieldMetaData("systemException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
  }
  {
    FieldMetaData.addStructMetaDataMap(RemoveFolder_result, metaDataMap);
  }

  public function RemoveFolder_result() {
  }

  public function get systemException():SystemException {
    return this._systemException;
  }

  public function set systemException(systemException:SystemException):void {
    this._systemException = systemException;
  }

  public function unsetSystemException():void {
    this.systemException = null;
  }

  // Returns true if field systemException is set (has been assigned a value) and false otherwise
  public function isSetSystemException():Boolean {
    return this.systemException != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case SYSTEMEXCEPTION:
      if (value == null) {
        unsetSystemException();
      } else {
        this.systemException = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case SYSTEMEXCEPTION:
      return this.systemException;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case SYSTEMEXCEPTION:
      return isSetSystemException();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case SYSTEMEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.systemException = new SystemException();
            this.systemException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    if (this.isSetSystemException()) {
      oprot.writeFieldBegin(SYSTEM_EXCEPTION_FIELD_DESC);
      this.systemException.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("RemoveFolder_result(");
    var first:Boolean = true;

    ret += "systemException:";
    if (this.systemException == null) {
      ret += "null";
    } else {
      ret += this.systemException;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class GetDeviceID_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("GetDeviceID_args");
  private static const AUTH_TOKEN_FIELD_DESC:TField = new TField("authToken", TType.STRING, 1);
  private static const SESSION_ID_FIELD_DESC:TField = new TField("sessionID", TType.STRING, 2);

  private var _authToken:String;
  public static const AUTHTOKEN:int = 1;
  private var _sessionID:String;
  public static const SESSIONID:int = 2;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[AUTHTOKEN] = new FieldMetaData("authToken", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
    metaDataMap[SESSIONID] = new FieldMetaData("sessionID", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
  }
  {
    FieldMetaData.addStructMetaDataMap(GetDeviceID_args, metaDataMap);
  }

  public function GetDeviceID_args() {
  }

  public function get authToken():String {
    return this._authToken;
  }

  public function set authToken(authToken:String):void {
    this._authToken = authToken;
  }

  public function unsetAuthToken():void {
    this.authToken = null;
  }

  // Returns true if field authToken is set (has been assigned a value) and false otherwise
  public function isSetAuthToken():Boolean {
    return this.authToken != null;
  }

  public function get sessionID():String {
    return this._sessionID;
  }

  public function set sessionID(sessionID:String):void {
    this._sessionID = sessionID;
  }

  public function unsetSessionID():void {
    this.sessionID = null;
  }

  // Returns true if field sessionID is set (has been assigned a value) and false otherwise
  public function isSetSessionID():Boolean {
    return this.sessionID != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case AUTHTOKEN:
      if (value == null) {
        unsetAuthToken();
      } else {
        this.authToken = value;
      }
      break;

    case SESSIONID:
      if (value == null) {
        unsetSessionID();
      } else {
        this.sessionID = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case AUTHTOKEN:
      return this.authToken;
    case SESSIONID:
      return this.sessionID;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case AUTHTOKEN:
      return isSetAuthToken();
    case SESSIONID:
      return isSetSessionID();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case AUTHTOKEN:
          if (field.type == TType.STRING) {
            this.authToken = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SESSIONID:
          if (field.type == TType.STRING) {
            this.sessionID = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    if (this.authToken != null) {
      oprot.writeFieldBegin(AUTH_TOKEN_FIELD_DESC);
      oprot.writeString(this.authToken);
      oprot.writeFieldEnd();
    }
    if (this.sessionID != null) {
      oprot.writeFieldBegin(SESSION_ID_FIELD_DESC);
      oprot.writeString(this.sessionID);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("GetDeviceID_args(");
    var first:Boolean = true;

    ret += "authToken:";
    if (this.authToken == null) {
      ret += "null";
    } else {
      ret += this.authToken;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "sessionID:";
    if (this.sessionID == null) {
      ret += "null";
    } else {
      ret += this.sessionID;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class GetDeviceID_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("GetDeviceID_result");
  private static const SUCCESS_FIELD_DESC:TField = new TField("success", TType.STRING, 0);
  private static const SYSTEM_EXCEPTION_FIELD_DESC:TField = new TField("systemException", TType.STRUCT, 1);

  private var _success:String;
  public static const SUCCESS:int = 0;
  private var _systemException:SystemException;
  public static const SYSTEMEXCEPTION:int = 1;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[SUCCESS] = new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
    metaDataMap[SYSTEMEXCEPTION] = new FieldMetaData("systemException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
  }
  {
    FieldMetaData.addStructMetaDataMap(GetDeviceID_result, metaDataMap);
  }

  public function GetDeviceID_result() {
  }

  public function get success():String {
    return this._success;
  }

  public function set success(success:String):void {
    this._success = success;
  }

  public function unsetSuccess():void {
    this.success = null;
  }

  // Returns true if field success is set (has been assigned a value) and false otherwise
  public function isSetSuccess():Boolean {
    return this.success != null;
  }

  public function get systemException():SystemException {
    return this._systemException;
  }

  public function set systemException(systemException:SystemException):void {
    this._systemException = systemException;
  }

  public function unsetSystemException():void {
    this.systemException = null;
  }

  // Returns true if field systemException is set (has been assigned a value) and false otherwise
  public function isSetSystemException():Boolean {
    return this.systemException != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case SUCCESS:
      if (value == null) {
        unsetSuccess();
      } else {
        this.success = value;
      }
      break;

    case SYSTEMEXCEPTION:
      if (value == null) {
        unsetSystemException();
      } else {
        this.systemException = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case SUCCESS:
      return this.success;
    case SYSTEMEXCEPTION:
      return this.systemException;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case SUCCESS:
      return isSetSuccess();
    case SYSTEMEXCEPTION:
      return isSetSystemException();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case SUCCESS:
          if (field.type == TType.STRING) {
            this.success = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SYSTEMEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.systemException = new SystemException();
            this.systemException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
      oprot.writeString(this.success);
      oprot.writeFieldEnd();
    } else if (this.isSetSystemException()) {
      oprot.writeFieldBegin(SYSTEM_EXCEPTION_FIELD_DESC);
      this.systemException.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("GetDeviceID_result(");
    var first:Boolean = true;

    ret += "success:";
    if (this.success == null) {
      ret += "null";
    } else {
      ret += this.success;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "systemException:";
    if (this.systemException == null) {
      ret += "null";
    } else {
      ret += this.systemException;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class GetFileCount_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("GetFileCount_args");
  private static const ID_FIELD_DESC:TField = new TField("id", TType.STRUCT, 1);
  private static const FOLDER_FIELD_DESC:TField = new TField("folder", TType.STRING, 2);

  private var _id:TaskID;
  public static const ID:int = 1;
  private var _folder:String;
  public static const FOLDER:int = 2;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[ID] = new FieldMetaData("id", TFieldRequirementType.DEFAULT, 
        new StructMetaData(TType.STRUCT, TaskID));
    metaDataMap[FOLDER] = new FieldMetaData("folder", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
  }
  {
    FieldMetaData.addStructMetaDataMap(GetFileCount_args, metaDataMap);
  }

  public function GetFileCount_args() {
  }

  public function get id():TaskID {
    return this._id;
  }

  public function set id(id:TaskID):void {
    this._id = id;
  }

  public function unsetId():void {
    this.id = null;
  }

  // Returns true if field id is set (has been assigned a value) and false otherwise
  public function isSetId():Boolean {
    return this.id != null;
  }

  public function get folder():String {
    return this._folder;
  }

  public function set folder(folder:String):void {
    this._folder = folder;
  }

  public function unsetFolder():void {
    this.folder = null;
  }

  // Returns true if field folder is set (has been assigned a value) and false otherwise
  public function isSetFolder():Boolean {
    return this.folder != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case ID:
      if (value == null) {
        unsetId();
      } else {
        this.id = value;
      }
      break;

    case FOLDER:
      if (value == null) {
        unsetFolder();
      } else {
        this.folder = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case ID:
      return this.id;
    case FOLDER:
      return this.folder;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case ID:
      return isSetId();
    case FOLDER:
      return isSetFolder();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case ID:
          if (field.type == TType.STRUCT) {
            this.id = new TaskID();
            this.id.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case FOLDER:
          if (field.type == TType.STRING) {
            this.folder = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    if (this.id != null) {
      oprot.writeFieldBegin(ID_FIELD_DESC);
      this.id.write(oprot);
      oprot.writeFieldEnd();
    }
    if (this.folder != null) {
      oprot.writeFieldBegin(FOLDER_FIELD_DESC);
      oprot.writeString(this.folder);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("GetFileCount_args(");
    var first:Boolean = true;

    ret += "id:";
    if (this.id == null) {
      ret += "null";
    } else {
      ret += this.id;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "folder:";
    if (this.folder == null) {
      ret += "null";
    } else {
      ret += this.folder;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class GetFileCount_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("GetFileCount_result");
  private static const SUCCESS_FIELD_DESC:TField = new TField("success", TType.I32, 0);
  private static const SYSTEM_EXCEPTION_FIELD_DESC:TField = new TField("systemException", TType.STRUCT, 1);

  private var _success:int;
  public static const SUCCESS:int = 0;
  private var _systemException:SystemException;
  public static const SYSTEMEXCEPTION:int = 1;

  private var __isset_success:Boolean = false;

  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[SUCCESS] = new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.I32));
    metaDataMap[SYSTEMEXCEPTION] = new FieldMetaData("systemException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
  }
  {
    FieldMetaData.addStructMetaDataMap(GetFileCount_result, metaDataMap);
  }

  public function GetFileCount_result() {
  }

  public function get success():int {
    return this._success;
  }

  public function set success(success:int):void {
    this._success = success;
    this.__isset_success = true;
  }

  public function unsetSuccess():void {
    this.__isset_success = false;
  }

  // Returns true if field success is set (has been assigned a value) and false otherwise
  public function isSetSuccess():Boolean {
    return this.__isset_success;
  }

  public function get systemException():SystemException {
    return this._systemException;
  }

  public function set systemException(systemException:SystemException):void {
    this._systemException = systemException;
  }

  public function unsetSystemException():void {
    this.systemException = null;
  }

  // Returns true if field systemException is set (has been assigned a value) and false otherwise
  public function isSetSystemException():Boolean {
    return this.systemException != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case SUCCESS:
      if (value == null) {
        unsetSuccess();
      } else {
        this.success = value;
      }
      break;

    case SYSTEMEXCEPTION:
      if (value == null) {
        unsetSystemException();
      } else {
        this.systemException = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case SUCCESS:
      return this.success;
    case SYSTEMEXCEPTION:
      return this.systemException;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case SUCCESS:
      return isSetSuccess();
    case SYSTEMEXCEPTION:
      return isSetSystemException();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case SUCCESS:
          if (field.type == TType.I32) {
            this.success = iprot.readI32();
            this.__isset_success = true;
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SYSTEMEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.systemException = new SystemException();
            this.systemException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
      oprot.writeI32(this.success);
      oprot.writeFieldEnd();
    } else if (this.isSetSystemException()) {
      oprot.writeFieldBegin(SYSTEM_EXCEPTION_FIELD_DESC);
      this.systemException.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("GetFileCount_result(");
    var first:Boolean = true;

    ret += "success:";
    ret += this.success;
    first = false;
    if (!first) ret +=  ", ";
    ret += "systemException:";
    if (this.systemException == null) {
      ret += "null";
    } else {
      ret += this.systemException;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class GetFiles_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("GetFiles_args");
  private static const ID_FIELD_DESC:TField = new TField("id", TType.STRUCT, 1);
  private static const FOLDER_FIELD_DESC:TField = new TField("folder", TType.STRING, 2);

  private var _id:TaskID;
  public static const ID:int = 1;
  private var _folder:String;
  public static const FOLDER:int = 2;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[ID] = new FieldMetaData("id", TFieldRequirementType.DEFAULT, 
        new StructMetaData(TType.STRUCT, TaskID));
    metaDataMap[FOLDER] = new FieldMetaData("folder", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
  }
  {
    FieldMetaData.addStructMetaDataMap(GetFiles_args, metaDataMap);
  }

  public function GetFiles_args() {
  }

  public function get id():TaskID {
    return this._id;
  }

  public function set id(id:TaskID):void {
    this._id = id;
  }

  public function unsetId():void {
    this.id = null;
  }

  // Returns true if field id is set (has been assigned a value) and false otherwise
  public function isSetId():Boolean {
    return this.id != null;
  }

  public function get folder():String {
    return this._folder;
  }

  public function set folder(folder:String):void {
    this._folder = folder;
  }

  public function unsetFolder():void {
    this.folder = null;
  }

  // Returns true if field folder is set (has been assigned a value) and false otherwise
  public function isSetFolder():Boolean {
    return this.folder != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case ID:
      if (value == null) {
        unsetId();
      } else {
        this.id = value;
      }
      break;

    case FOLDER:
      if (value == null) {
        unsetFolder();
      } else {
        this.folder = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case ID:
      return this.id;
    case FOLDER:
      return this.folder;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case ID:
      return isSetId();
    case FOLDER:
      return isSetFolder();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case ID:
          if (field.type == TType.STRUCT) {
            this.id = new TaskID();
            this.id.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case FOLDER:
          if (field.type == TType.STRING) {
            this.folder = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    if (this.id != null) {
      oprot.writeFieldBegin(ID_FIELD_DESC);
      this.id.write(oprot);
      oprot.writeFieldEnd();
    }
    if (this.folder != null) {
      oprot.writeFieldBegin(FOLDER_FIELD_DESC);
      oprot.writeString(this.folder);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("GetFiles_args(");
    var first:Boolean = true;

    ret += "id:";
    if (this.id == null) {
      ret += "null";
    } else {
      ret += this.id;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "folder:";
    if (this.folder == null) {
      ret += "null";
    } else {
      ret += this.folder;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class GetFiles_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("GetFiles_result");
  private static const SUCCESS_FIELD_DESC:TField = new TField("success", TType.LIST, 0);
  private static const SYSTEM_EXCEPTION_FIELD_DESC:TField = new TField("systemException", TType.STRUCT, 1);

  private var _success:Array;
  public static const SUCCESS:int = 0;
  private var _systemException:SystemException;
  public static const SYSTEMEXCEPTION:int = 1;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[SUCCESS] = new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
        new ListMetaData(TType.LIST, 
            new FieldValueMetaData(TType.STRING)));
    metaDataMap[SYSTEMEXCEPTION] = new FieldMetaData("systemException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
  }
  {
    FieldMetaData.addStructMetaDataMap(GetFiles_result, metaDataMap);
  }

  public function GetFiles_result() {
  }

  public function get success():Array {
    return this._success;
  }

  public function set success(success:Array):void {
    this._success = success;
  }

  public function unsetSuccess():void {
    this.success = null;
  }

  // Returns true if field success is set (has been assigned a value) and false otherwise
  public function isSetSuccess():Boolean {
    return this.success != null;
  }

  public function get systemException():SystemException {
    return this._systemException;
  }

  public function set systemException(systemException:SystemException):void {
    this._systemException = systemException;
  }

  public function unsetSystemException():void {
    this.systemException = null;
  }

  // Returns true if field systemException is set (has been assigned a value) and false otherwise
  public function isSetSystemException():Boolean {
    return this.systemException != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case SUCCESS:
      if (value == null) {
        unsetSuccess();
      } else {
        this.success = value;
      }
      break;

    case SYSTEMEXCEPTION:
      if (value == null) {
        unsetSystemException();
      } else {
        this.systemException = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case SUCCESS:
      return this.success;
    case SYSTEMEXCEPTION:
      return this.systemException;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case SUCCESS:
      return isSetSuccess();
    case SYSTEMEXCEPTION:
      return isSetSystemException();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case SUCCESS:
          if (field.type == TType.LIST) {
            {
              var _list27:TList = iprot.readListBegin();
              this.success = new Array();
              for (var _i28:int = 0; _i28 < _list27.size; ++_i28)
              {
                var _elem29:String;
                _elem29 = iprot.readString();
                this.success.push(_elem29);
              }
              iprot.readListEnd();
            }
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SYSTEMEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.systemException = new SystemException();
            this.systemException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRING, this.success.length));
        for each (var elem30:* in this.success)        {
          oprot.writeString(elem30);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    } else if (this.isSetSystemException()) {
      oprot.writeFieldBegin(SYSTEM_EXCEPTION_FIELD_DESC);
      this.systemException.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("GetFiles_result(");
    var first:Boolean = true;

    ret += "success:";
    if (this.success == null) {
      ret += "null";
    } else {
      ret += this.success;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "systemException:";
    if (this.systemException == null) {
      ret += "null";
    } else {
      ret += this.systemException;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class GetFolders_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("GetFolders_args");
  private static const ID_FIELD_DESC:TField = new TField("id", TType.STRUCT, 1);

  private var _id:TaskID;
  public static const ID:int = 1;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[ID] = new FieldMetaData("id", TFieldRequirementType.DEFAULT, 
        new StructMetaData(TType.STRUCT, TaskID));
  }
  {
    FieldMetaData.addStructMetaDataMap(GetFolders_args, metaDataMap);
  }

  public function GetFolders_args() {
  }

  public function get id():TaskID {
    return this._id;
  }

  public function set id(id:TaskID):void {
    this._id = id;
  }

  public function unsetId():void {
    this.id = null;
  }

  // Returns true if field id is set (has been assigned a value) and false otherwise
  public function isSetId():Boolean {
    return this.id != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case ID:
      if (value == null) {
        unsetId();
      } else {
        this.id = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case ID:
      return this.id;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case ID:
      return isSetId();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case ID:
          if (field.type == TType.STRUCT) {
            this.id = new TaskID();
            this.id.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    if (this.id != null) {
      oprot.writeFieldBegin(ID_FIELD_DESC);
      this.id.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("GetFolders_args(");
    var first:Boolean = true;

    ret += "id:";
    if (this.id == null) {
      ret += "null";
    } else {
      ret += this.id;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class GetFolders_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("GetFolders_result");
  private static const SUCCESS_FIELD_DESC:TField = new TField("success", TType.LIST, 0);
  private static const SYSTEM_EXCEPTION_FIELD_DESC:TField = new TField("systemException", TType.STRUCT, 1);

  private var _success:Array;
  public static const SUCCESS:int = 0;
  private var _systemException:SystemException;
  public static const SYSTEMEXCEPTION:int = 1;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[SUCCESS] = new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
        new ListMetaData(TType.LIST, 
            new FieldValueMetaData(TType.STRING)));
    metaDataMap[SYSTEMEXCEPTION] = new FieldMetaData("systemException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
  }
  {
    FieldMetaData.addStructMetaDataMap(GetFolders_result, metaDataMap);
  }

  public function GetFolders_result() {
  }

  public function get success():Array {
    return this._success;
  }

  public function set success(success:Array):void {
    this._success = success;
  }

  public function unsetSuccess():void {
    this.success = null;
  }

  // Returns true if field success is set (has been assigned a value) and false otherwise
  public function isSetSuccess():Boolean {
    return this.success != null;
  }

  public function get systemException():SystemException {
    return this._systemException;
  }

  public function set systemException(systemException:SystemException):void {
    this._systemException = systemException;
  }

  public function unsetSystemException():void {
    this.systemException = null;
  }

  // Returns true if field systemException is set (has been assigned a value) and false otherwise
  public function isSetSystemException():Boolean {
    return this.systemException != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case SUCCESS:
      if (value == null) {
        unsetSuccess();
      } else {
        this.success = value;
      }
      break;

    case SYSTEMEXCEPTION:
      if (value == null) {
        unsetSystemException();
      } else {
        this.systemException = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case SUCCESS:
      return this.success;
    case SYSTEMEXCEPTION:
      return this.systemException;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case SUCCESS:
      return isSetSuccess();
    case SYSTEMEXCEPTION:
      return isSetSystemException();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case SUCCESS:
          if (field.type == TType.LIST) {
            {
              var _list34:TList = iprot.readListBegin();
              this.success = new Array();
              for (var _i35:int = 0; _i35 < _list34.size; ++_i35)
              {
                var _elem36:String;
                _elem36 = iprot.readString();
                this.success.push(_elem36);
              }
              iprot.readListEnd();
            }
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SYSTEMEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.systemException = new SystemException();
            this.systemException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRING, this.success.length));
        for each (var elem37:* in this.success)        {
          oprot.writeString(elem37);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    } else if (this.isSetSystemException()) {
      oprot.writeFieldBegin(SYSTEM_EXCEPTION_FIELD_DESC);
      this.systemException.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("GetFolders_result(");
    var first:Boolean = true;

    ret += "success:";
    if (this.success == null) {
      ret += "null";
    } else {
      ret += this.success;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "systemException:";
    if (this.systemException == null) {
      ret += "null";
    } else {
      ret += this.systemException;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class GetState_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("GetState_args");
  private static const ID_FIELD_DESC:TField = new TField("id", TType.STRUCT, 1);

  private var _id:TaskID;
  public static const ID:int = 1;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[ID] = new FieldMetaData("id", TFieldRequirementType.DEFAULT, 
        new StructMetaData(TType.STRUCT, TaskID));
  }
  {
    FieldMetaData.addStructMetaDataMap(GetState_args, metaDataMap);
  }

  public function GetState_args() {
  }

  public function get id():TaskID {
    return this._id;
  }

  public function set id(id:TaskID):void {
    this._id = id;
  }

  public function unsetId():void {
    this.id = null;
  }

  // Returns true if field id is set (has been assigned a value) and false otherwise
  public function isSetId():Boolean {
    return this.id != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case ID:
      if (value == null) {
        unsetId();
      } else {
        this.id = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case ID:
      return this.id;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case ID:
      return isSetId();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case ID:
          if (field.type == TType.STRUCT) {
            this.id = new TaskID();
            this.id.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    if (this.id != null) {
      oprot.writeFieldBegin(ID_FIELD_DESC);
      this.id.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("GetState_args(");
    var first:Boolean = true;

    ret += "id:";
    if (this.id == null) {
      ret += "null";
    } else {
      ret += this.id;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class GetState_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("GetState_result");
  private static const SUCCESS_FIELD_DESC:TField = new TField("success", TType.STRUCT, 0);
  private static const SYSTEM_EXCEPTION_FIELD_DESC:TField = new TField("systemException", TType.STRUCT, 1);

  private var _success:URTaskState;
  public static const SUCCESS:int = 0;
  private var _systemException:SystemException;
  public static const SYSTEMEXCEPTION:int = 1;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[SUCCESS] = new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
        new StructMetaData(TType.STRUCT, URTaskState));
    metaDataMap[SYSTEMEXCEPTION] = new FieldMetaData("systemException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
  }
  {
    FieldMetaData.addStructMetaDataMap(GetState_result, metaDataMap);
  }

  public function GetState_result() {
  }

  public function get success():URTaskState {
    return this._success;
  }

  public function set success(success:URTaskState):void {
    this._success = success;
  }

  public function unsetSuccess():void {
    this.success = null;
  }

  // Returns true if field success is set (has been assigned a value) and false otherwise
  public function isSetSuccess():Boolean {
    return this.success != null;
  }

  public function get systemException():SystemException {
    return this._systemException;
  }

  public function set systemException(systemException:SystemException):void {
    this._systemException = systemException;
  }

  public function unsetSystemException():void {
    this.systemException = null;
  }

  // Returns true if field systemException is set (has been assigned a value) and false otherwise
  public function isSetSystemException():Boolean {
    return this.systemException != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case SUCCESS:
      if (value == null) {
        unsetSuccess();
      } else {
        this.success = value;
      }
      break;

    case SYSTEMEXCEPTION:
      if (value == null) {
        unsetSystemException();
      } else {
        this.systemException = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case SUCCESS:
      return this.success;
    case SYSTEMEXCEPTION:
      return this.systemException;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case SUCCESS:
      return isSetSuccess();
    case SYSTEMEXCEPTION:
      return isSetSystemException();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case SUCCESS:
          if (field.type == TType.STRUCT) {
            this.success = new URTaskState();
            this.success.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SYSTEMEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.systemException = new SystemException();
            this.systemException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
      this.success.write(oprot);
      oprot.writeFieldEnd();
    } else if (this.isSetSystemException()) {
      oprot.writeFieldBegin(SYSTEM_EXCEPTION_FIELD_DESC);
      this.systemException.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("GetState_result(");
    var first:Boolean = true;

    ret += "success:";
    if (this.success == null) {
      ret += "null";
    } else {
      ret += this.success;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "systemException:";
    if (this.systemException == null) {
      ret += "null";
    } else {
      ret += this.systemException;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class GetWatchedFolders_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("GetWatchedFolders_args");
  private static const ID_FIELD_DESC:TField = new TField("id", TType.STRUCT, 1);

  private var _id:TaskID;
  public static const ID:int = 1;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[ID] = new FieldMetaData("id", TFieldRequirementType.DEFAULT, 
        new StructMetaData(TType.STRUCT, TaskID));
  }
  {
    FieldMetaData.addStructMetaDataMap(GetWatchedFolders_args, metaDataMap);
  }

  public function GetWatchedFolders_args() {
  }

  public function get id():TaskID {
    return this._id;
  }

  public function set id(id:TaskID):void {
    this._id = id;
  }

  public function unsetId():void {
    this.id = null;
  }

  // Returns true if field id is set (has been assigned a value) and false otherwise
  public function isSetId():Boolean {
    return this.id != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case ID:
      if (value == null) {
        unsetId();
      } else {
        this.id = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case ID:
      return this.id;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case ID:
      return isSetId();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case ID:
          if (field.type == TType.STRUCT) {
            this.id = new TaskID();
            this.id.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    if (this.id != null) {
      oprot.writeFieldBegin(ID_FIELD_DESC);
      this.id.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("GetWatchedFolders_args(");
    var first:Boolean = true;

    ret += "id:";
    if (this.id == null) {
      ret += "null";
    } else {
      ret += this.id;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class GetWatchedFolders_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("GetWatchedFolders_result");
  private static const SUCCESS_FIELD_DESC:TField = new TField("success", TType.LIST, 0);
  private static const SYSTEM_EXCEPTION_FIELD_DESC:TField = new TField("systemException", TType.STRUCT, 1);

  private var _success:Array;
  public static const SUCCESS:int = 0;
  private var _systemException:SystemException;
  public static const SYSTEMEXCEPTION:int = 1;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[SUCCESS] = new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
        new ListMetaData(TType.LIST, 
            new FieldValueMetaData(TType.STRING)));
    metaDataMap[SYSTEMEXCEPTION] = new FieldMetaData("systemException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
  }
  {
    FieldMetaData.addStructMetaDataMap(GetWatchedFolders_result, metaDataMap);
  }

  public function GetWatchedFolders_result() {
  }

  public function get success():Array {
    return this._success;
  }

  public function set success(success:Array):void {
    this._success = success;
  }

  public function unsetSuccess():void {
    this.success = null;
  }

  // Returns true if field success is set (has been assigned a value) and false otherwise
  public function isSetSuccess():Boolean {
    return this.success != null;
  }

  public function get systemException():SystemException {
    return this._systemException;
  }

  public function set systemException(systemException:SystemException):void {
    this._systemException = systemException;
  }

  public function unsetSystemException():void {
    this.systemException = null;
  }

  // Returns true if field systemException is set (has been assigned a value) and false otherwise
  public function isSetSystemException():Boolean {
    return this.systemException != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case SUCCESS:
      if (value == null) {
        unsetSuccess();
      } else {
        this.success = value;
      }
      break;

    case SYSTEMEXCEPTION:
      if (value == null) {
        unsetSystemException();
      } else {
        this.systemException = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case SUCCESS:
      return this.success;
    case SYSTEMEXCEPTION:
      return this.systemException;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case SUCCESS:
      return isSetSuccess();
    case SYSTEMEXCEPTION:
      return isSetSystemException();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case SUCCESS:
          if (field.type == TType.LIST) {
            {
              var _list44:TList = iprot.readListBegin();
              this.success = new Array();
              for (var _i45:int = 0; _i45 < _list44.size; ++_i45)
              {
                var _elem46:String;
                _elem46 = iprot.readString();
                this.success.push(_elem46);
              }
              iprot.readListEnd();
            }
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case SYSTEMEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.systemException = new SystemException();
            this.systemException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    if (this.isSetSuccess()) {
      oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
      {
        oprot.writeListBegin(new TList(TType.STRING, this.success.length));
        for each (var elem47:* in this.success)        {
          oprot.writeString(elem47);
        }
        oprot.writeListEnd();
      }
      oprot.writeFieldEnd();
    } else if (this.isSetSystemException()) {
      oprot.writeFieldBegin(SYSTEM_EXCEPTION_FIELD_DESC);
      this.systemException.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("GetWatchedFolders_result(");
    var first:Boolean = true;

    ret += "success:";
    if (this.success == null) {
      ret += "null";
    } else {
      ret += this.success;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "systemException:";
    if (this.systemException == null) {
      ret += "null";
    } else {
      ret += this.systemException;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class ReportFileCount_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("ReportFileCount_args");
  private static const ID_FIELD_DESC:TField = new TField("id", TType.STRUCT, 1);
  private static const FOLDER_FIELD_DESC:TField = new TField("folder", TType.STRING, 2);
  private static const COUNT_FIELD_DESC:TField = new TField("count", TType.I32, 3);

  private var _id:TaskID;
  public static const ID:int = 1;
  private var _folder:String;
  public static const FOLDER:int = 2;
  private var _count:int;
  public static const COUNT:int = 3;

  private var __isset_count:Boolean = false;

  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[ID] = new FieldMetaData("id", TFieldRequirementType.DEFAULT, 
        new StructMetaData(TType.STRUCT, TaskID));
    metaDataMap[FOLDER] = new FieldMetaData("folder", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
    metaDataMap[COUNT] = new FieldMetaData("count", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.I32));
  }
  {
    FieldMetaData.addStructMetaDataMap(ReportFileCount_args, metaDataMap);
  }

  public function ReportFileCount_args() {
  }

  public function get id():TaskID {
    return this._id;
  }

  public function set id(id:TaskID):void {
    this._id = id;
  }

  public function unsetId():void {
    this.id = null;
  }

  // Returns true if field id is set (has been assigned a value) and false otherwise
  public function isSetId():Boolean {
    return this.id != null;
  }

  public function get folder():String {
    return this._folder;
  }

  public function set folder(folder:String):void {
    this._folder = folder;
  }

  public function unsetFolder():void {
    this.folder = null;
  }

  // Returns true if field folder is set (has been assigned a value) and false otherwise
  public function isSetFolder():Boolean {
    return this.folder != null;
  }

  public function get count():int {
    return this._count;
  }

  public function set count(count:int):void {
    this._count = count;
    this.__isset_count = true;
  }

  public function unsetCount():void {
    this.__isset_count = false;
  }

  // Returns true if field count is set (has been assigned a value) and false otherwise
  public function isSetCount():Boolean {
    return this.__isset_count;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case ID:
      if (value == null) {
        unsetId();
      } else {
        this.id = value;
      }
      break;

    case FOLDER:
      if (value == null) {
        unsetFolder();
      } else {
        this.folder = value;
      }
      break;

    case COUNT:
      if (value == null) {
        unsetCount();
      } else {
        this.count = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case ID:
      return this.id;
    case FOLDER:
      return this.folder;
    case COUNT:
      return this.count;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case ID:
      return isSetId();
    case FOLDER:
      return isSetFolder();
    case COUNT:
      return isSetCount();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case ID:
          if (field.type == TType.STRUCT) {
            this.id = new TaskID();
            this.id.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case FOLDER:
          if (field.type == TType.STRING) {
            this.folder = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case COUNT:
          if (field.type == TType.I32) {
            this.count = iprot.readI32();
            this.__isset_count = true;
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    if (this.id != null) {
      oprot.writeFieldBegin(ID_FIELD_DESC);
      this.id.write(oprot);
      oprot.writeFieldEnd();
    }
    if (this.folder != null) {
      oprot.writeFieldBegin(FOLDER_FIELD_DESC);
      oprot.writeString(this.folder);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldBegin(COUNT_FIELD_DESC);
    oprot.writeI32(this.count);
    oprot.writeFieldEnd();
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("ReportFileCount_args(");
    var first:Boolean = true;

    ret += "id:";
    if (this.id == null) {
      ret += "null";
    } else {
      ret += this.id;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "folder:";
    if (this.folder == null) {
      ret += "null";
    } else {
      ret += this.folder;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "count:";
    ret += this.count;
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class ReportFileCount_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("ReportFileCount_result");
  private static const SYSTEM_EXCEPTION_FIELD_DESC:TField = new TField("systemException", TType.STRUCT, 1);

  private var _systemException:SystemException;
  public static const SYSTEMEXCEPTION:int = 1;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[SYSTEMEXCEPTION] = new FieldMetaData("systemException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
  }
  {
    FieldMetaData.addStructMetaDataMap(ReportFileCount_result, metaDataMap);
  }

  public function ReportFileCount_result() {
  }

  public function get systemException():SystemException {
    return this._systemException;
  }

  public function set systemException(systemException:SystemException):void {
    this._systemException = systemException;
  }

  public function unsetSystemException():void {
    this.systemException = null;
  }

  // Returns true if field systemException is set (has been assigned a value) and false otherwise
  public function isSetSystemException():Boolean {
    return this.systemException != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case SYSTEMEXCEPTION:
      if (value == null) {
        unsetSystemException();
      } else {
        this.systemException = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case SYSTEMEXCEPTION:
      return this.systemException;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case SYSTEMEXCEPTION:
      return isSetSystemException();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case SYSTEMEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.systemException = new SystemException();
            this.systemException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    if (this.isSetSystemException()) {
      oprot.writeFieldBegin(SYSTEM_EXCEPTION_FIELD_DESC);
      this.systemException.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("ReportFileCount_result(");
    var first:Boolean = true;

    ret += "systemException:";
    if (this.systemException == null) {
      ret += "null";
    } else {
      ret += this.systemException;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class ReportFolderNotFound_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("ReportFolderNotFound_args");
  private static const ID_FIELD_DESC:TField = new TField("id", TType.STRUCT, 1);
  private static const FOLDER_FIELD_DESC:TField = new TField("folder", TType.STRING, 2);

  private var _id:TaskID;
  public static const ID:int = 1;
  private var _folder:String;
  public static const FOLDER:int = 2;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[ID] = new FieldMetaData("id", TFieldRequirementType.DEFAULT, 
        new StructMetaData(TType.STRUCT, TaskID));
    metaDataMap[FOLDER] = new FieldMetaData("folder", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
  }
  {
    FieldMetaData.addStructMetaDataMap(ReportFolderNotFound_args, metaDataMap);
  }

  public function ReportFolderNotFound_args() {
  }

  public function get id():TaskID {
    return this._id;
  }

  public function set id(id:TaskID):void {
    this._id = id;
  }

  public function unsetId():void {
    this.id = null;
  }

  // Returns true if field id is set (has been assigned a value) and false otherwise
  public function isSetId():Boolean {
    return this.id != null;
  }

  public function get folder():String {
    return this._folder;
  }

  public function set folder(folder:String):void {
    this._folder = folder;
  }

  public function unsetFolder():void {
    this.folder = null;
  }

  // Returns true if field folder is set (has been assigned a value) and false otherwise
  public function isSetFolder():Boolean {
    return this.folder != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case ID:
      if (value == null) {
        unsetId();
      } else {
        this.id = value;
      }
      break;

    case FOLDER:
      if (value == null) {
        unsetFolder();
      } else {
        this.folder = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case ID:
      return this.id;
    case FOLDER:
      return this.folder;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case ID:
      return isSetId();
    case FOLDER:
      return isSetFolder();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case ID:
          if (field.type == TType.STRUCT) {
            this.id = new TaskID();
            this.id.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case FOLDER:
          if (field.type == TType.STRING) {
            this.folder = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    if (this.id != null) {
      oprot.writeFieldBegin(ID_FIELD_DESC);
      this.id.write(oprot);
      oprot.writeFieldEnd();
    }
    if (this.folder != null) {
      oprot.writeFieldBegin(FOLDER_FIELD_DESC);
      oprot.writeString(this.folder);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("ReportFolderNotFound_args(");
    var first:Boolean = true;

    ret += "id:";
    if (this.id == null) {
      ret += "null";
    } else {
      ret += this.id;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "folder:";
    if (this.folder == null) {
      ret += "null";
    } else {
      ret += this.folder;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class ReportFolderNotFound_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("ReportFolderNotFound_result");
  private static const SYSTEM_EXCEPTION_FIELD_DESC:TField = new TField("systemException", TType.STRUCT, 1);

  private var _systemException:SystemException;
  public static const SYSTEMEXCEPTION:int = 1;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[SYSTEMEXCEPTION] = new FieldMetaData("systemException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
  }
  {
    FieldMetaData.addStructMetaDataMap(ReportFolderNotFound_result, metaDataMap);
  }

  public function ReportFolderNotFound_result() {
  }

  public function get systemException():SystemException {
    return this._systemException;
  }

  public function set systemException(systemException:SystemException):void {
    this._systemException = systemException;
  }

  public function unsetSystemException():void {
    this.systemException = null;
  }

  // Returns true if field systemException is set (has been assigned a value) and false otherwise
  public function isSetSystemException():Boolean {
    return this.systemException != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case SYSTEMEXCEPTION:
      if (value == null) {
        unsetSystemException();
      } else {
        this.systemException = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case SYSTEMEXCEPTION:
      return this.systemException;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case SYSTEMEXCEPTION:
      return isSetSystemException();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case SYSTEMEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.systemException = new SystemException();
            this.systemException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    if (this.isSetSystemException()) {
      oprot.writeFieldBegin(SYSTEM_EXCEPTION_FIELD_DESC);
      this.systemException.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("ReportFolderNotFound_result(");
    var first:Boolean = true;

    ret += "systemException:";
    if (this.systemException == null) {
      ret += "null";
    } else {
      ret += this.systemException;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class ReportFolderUploadComplete_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("ReportFolderUploadComplete_args");
  private static const ID_FIELD_DESC:TField = new TField("id", TType.STRUCT, 1);
  private static const FOLDER_FIELD_DESC:TField = new TField("folder", TType.STRING, 2);

  private var _id:TaskID;
  public static const ID:int = 1;
  private var _folder:String;
  public static const FOLDER:int = 2;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[ID] = new FieldMetaData("id", TFieldRequirementType.DEFAULT, 
        new StructMetaData(TType.STRUCT, TaskID));
    metaDataMap[FOLDER] = new FieldMetaData("folder", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
  }
  {
    FieldMetaData.addStructMetaDataMap(ReportFolderUploadComplete_args, metaDataMap);
  }

  public function ReportFolderUploadComplete_args() {
  }

  public function get id():TaskID {
    return this._id;
  }

  public function set id(id:TaskID):void {
    this._id = id;
  }

  public function unsetId():void {
    this.id = null;
  }

  // Returns true if field id is set (has been assigned a value) and false otherwise
  public function isSetId():Boolean {
    return this.id != null;
  }

  public function get folder():String {
    return this._folder;
  }

  public function set folder(folder:String):void {
    this._folder = folder;
  }

  public function unsetFolder():void {
    this.folder = null;
  }

  // Returns true if field folder is set (has been assigned a value) and false otherwise
  public function isSetFolder():Boolean {
    return this.folder != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case ID:
      if (value == null) {
        unsetId();
      } else {
        this.id = value;
      }
      break;

    case FOLDER:
      if (value == null) {
        unsetFolder();
      } else {
        this.folder = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case ID:
      return this.id;
    case FOLDER:
      return this.folder;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case ID:
      return isSetId();
    case FOLDER:
      return isSetFolder();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case ID:
          if (field.type == TType.STRUCT) {
            this.id = new TaskID();
            this.id.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case FOLDER:
          if (field.type == TType.STRING) {
            this.folder = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    if (this.id != null) {
      oprot.writeFieldBegin(ID_FIELD_DESC);
      this.id.write(oprot);
      oprot.writeFieldEnd();
    }
    if (this.folder != null) {
      oprot.writeFieldBegin(FOLDER_FIELD_DESC);
      oprot.writeString(this.folder);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("ReportFolderUploadComplete_args(");
    var first:Boolean = true;

    ret += "id:";
    if (this.id == null) {
      ret += "null";
    } else {
      ret += this.id;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "folder:";
    if (this.folder == null) {
      ret += "null";
    } else {
      ret += this.folder;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class ReportFolderUploadComplete_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("ReportFolderUploadComplete_result");
  private static const SYSTEM_EXCEPTION_FIELD_DESC:TField = new TField("systemException", TType.STRUCT, 1);

  private var _systemException:SystemException;
  public static const SYSTEMEXCEPTION:int = 1;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[SYSTEMEXCEPTION] = new FieldMetaData("systemException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
  }
  {
    FieldMetaData.addStructMetaDataMap(ReportFolderUploadComplete_result, metaDataMap);
  }

  public function ReportFolderUploadComplete_result() {
  }

  public function get systemException():SystemException {
    return this._systemException;
  }

  public function set systemException(systemException:SystemException):void {
    this._systemException = systemException;
  }

  public function unsetSystemException():void {
    this.systemException = null;
  }

  // Returns true if field systemException is set (has been assigned a value) and false otherwise
  public function isSetSystemException():Boolean {
    return this.systemException != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case SYSTEMEXCEPTION:
      if (value == null) {
        unsetSystemException();
      } else {
        this.systemException = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case SYSTEMEXCEPTION:
      return this.systemException;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case SYSTEMEXCEPTION:
      return isSetSystemException();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case SYSTEMEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.systemException = new SystemException();
            this.systemException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    if (this.isSetSystemException()) {
      oprot.writeFieldBegin(SYSTEM_EXCEPTION_FIELD_DESC);
      this.systemException.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("ReportFolderUploadComplete_result(");
    var first:Boolean = true;

    ret += "systemException:";
    if (this.systemException == null) {
      ret += "null";
    } else {
      ret += this.systemException;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class ReportUploadFailed_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("ReportUploadFailed_args");
  private static const ID_FIELD_DESC:TField = new TField("id", TType.STRUCT, 1);
  private static const FOLDER_FIELD_DESC:TField = new TField("folder", TType.STRING, 2);
  private static const PATH_FIELD_DESC:TField = new TField("path", TType.STRING, 3);

  private var _id:TaskID;
  public static const ID:int = 1;
  private var _folder:String;
  public static const FOLDER:int = 2;
  private var _path:String;
  public static const PATH:int = 3;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[ID] = new FieldMetaData("id", TFieldRequirementType.DEFAULT, 
        new StructMetaData(TType.STRUCT, TaskID));
    metaDataMap[FOLDER] = new FieldMetaData("folder", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
    metaDataMap[PATH] = new FieldMetaData("path", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
  }
  {
    FieldMetaData.addStructMetaDataMap(ReportUploadFailed_args, metaDataMap);
  }

  public function ReportUploadFailed_args() {
  }

  public function get id():TaskID {
    return this._id;
  }

  public function set id(id:TaskID):void {
    this._id = id;
  }

  public function unsetId():void {
    this.id = null;
  }

  // Returns true if field id is set (has been assigned a value) and false otherwise
  public function isSetId():Boolean {
    return this.id != null;
  }

  public function get folder():String {
    return this._folder;
  }

  public function set folder(folder:String):void {
    this._folder = folder;
  }

  public function unsetFolder():void {
    this.folder = null;
  }

  // Returns true if field folder is set (has been assigned a value) and false otherwise
  public function isSetFolder():Boolean {
    return this.folder != null;
  }

  public function get path():String {
    return this._path;
  }

  public function set path(path:String):void {
    this._path = path;
  }

  public function unsetPath():void {
    this.path = null;
  }

  // Returns true if field path is set (has been assigned a value) and false otherwise
  public function isSetPath():Boolean {
    return this.path != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case ID:
      if (value == null) {
        unsetId();
      } else {
        this.id = value;
      }
      break;

    case FOLDER:
      if (value == null) {
        unsetFolder();
      } else {
        this.folder = value;
      }
      break;

    case PATH:
      if (value == null) {
        unsetPath();
      } else {
        this.path = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case ID:
      return this.id;
    case FOLDER:
      return this.folder;
    case PATH:
      return this.path;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case ID:
      return isSetId();
    case FOLDER:
      return isSetFolder();
    case PATH:
      return isSetPath();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case ID:
          if (field.type == TType.STRUCT) {
            this.id = new TaskID();
            this.id.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case FOLDER:
          if (field.type == TType.STRING) {
            this.folder = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case PATH:
          if (field.type == TType.STRING) {
            this.path = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    if (this.id != null) {
      oprot.writeFieldBegin(ID_FIELD_DESC);
      this.id.write(oprot);
      oprot.writeFieldEnd();
    }
    if (this.folder != null) {
      oprot.writeFieldBegin(FOLDER_FIELD_DESC);
      oprot.writeString(this.folder);
      oprot.writeFieldEnd();
    }
    if (this.path != null) {
      oprot.writeFieldBegin(PATH_FIELD_DESC);
      oprot.writeString(this.path);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("ReportUploadFailed_args(");
    var first:Boolean = true;

    ret += "id:";
    if (this.id == null) {
      ret += "null";
    } else {
      ret += this.id;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "folder:";
    if (this.folder == null) {
      ret += "null";
    } else {
      ret += this.folder;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "path:";
    if (this.path == null) {
      ret += "null";
    } else {
      ret += this.path;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class ReportUploadFailed_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("ReportUploadFailed_result");
  private static const SYSTEM_EXCEPTION_FIELD_DESC:TField = new TField("systemException", TType.STRUCT, 1);

  private var _systemException:SystemException;
  public static const SYSTEMEXCEPTION:int = 1;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[SYSTEMEXCEPTION] = new FieldMetaData("systemException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
  }
  {
    FieldMetaData.addStructMetaDataMap(ReportUploadFailed_result, metaDataMap);
  }

  public function ReportUploadFailed_result() {
  }

  public function get systemException():SystemException {
    return this._systemException;
  }

  public function set systemException(systemException:SystemException):void {
    this._systemException = systemException;
  }

  public function unsetSystemException():void {
    this.systemException = null;
  }

  // Returns true if field systemException is set (has been assigned a value) and false otherwise
  public function isSetSystemException():Boolean {
    return this.systemException != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case SYSTEMEXCEPTION:
      if (value == null) {
        unsetSystemException();
      } else {
        this.systemException = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case SYSTEMEXCEPTION:
      return this.systemException;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case SYSTEMEXCEPTION:
      return isSetSystemException();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case SYSTEMEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.systemException = new SystemException();
            this.systemException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    if (this.isSetSystemException()) {
      oprot.writeFieldBegin(SYSTEM_EXCEPTION_FIELD_DESC);
      this.systemException.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("ReportUploadFailed_result(");
    var first:Boolean = true;

    ret += "systemException:";
    if (this.systemException == null) {
      ret += "null";
    } else {
      ret += this.systemException;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class UploadFile_args implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("UploadFile_args");
  private static const ID_FIELD_DESC:TField = new TField("id", TType.STRUCT, 1);
  private static const PATH_FIELD_DESC:TField = new TField("path", TType.STRING, 2);
  private static const DATA_FIELD_DESC:TField = new TField("data", TType.STRING, 3);
  private static const INFO_FIELD_DESC:TField = new TField("info", TType.STRUCT, 4);

  private var _id:TaskID;
  public static const ID:int = 1;
  private var _path:String;
  public static const PATH:int = 2;
  private var _data:ByteArray;
  public static const DATA:int = 3;
  private var _info:UploadInfo;
  public static const INFO:int = 4;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[ID] = new FieldMetaData("id", TFieldRequirementType.DEFAULT, 
        new StructMetaData(TType.STRUCT, TaskID));
    metaDataMap[PATH] = new FieldMetaData("path", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
    metaDataMap[DATA] = new FieldMetaData("data", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRING));
    metaDataMap[INFO] = new FieldMetaData("info", TFieldRequirementType.DEFAULT, 
        new StructMetaData(TType.STRUCT, UploadInfo));
  }
  {
    FieldMetaData.addStructMetaDataMap(UploadFile_args, metaDataMap);
  }

  public function UploadFile_args() {
  }

  public function get id():TaskID {
    return this._id;
  }

  public function set id(id:TaskID):void {
    this._id = id;
  }

  public function unsetId():void {
    this.id = null;
  }

  // Returns true if field id is set (has been assigned a value) and false otherwise
  public function isSetId():Boolean {
    return this.id != null;
  }

  public function get path():String {
    return this._path;
  }

  public function set path(path:String):void {
    this._path = path;
  }

  public function unsetPath():void {
    this.path = null;
  }

  // Returns true if field path is set (has been assigned a value) and false otherwise
  public function isSetPath():Boolean {
    return this.path != null;
  }

  public function get data():ByteArray {
    return this._data;
  }

  public function set data(data:ByteArray):void {
    this._data = data;
  }

  public function unsetData():void {
    this.data = null;
  }

  // Returns true if field data is set (has been assigned a value) and false otherwise
  public function isSetData():Boolean {
    return this.data != null;
  }

  public function get info():UploadInfo {
    return this._info;
  }

  public function set info(info:UploadInfo):void {
    this._info = info;
  }

  public function unsetInfo():void {
    this.info = null;
  }

  // Returns true if field info is set (has been assigned a value) and false otherwise
  public function isSetInfo():Boolean {
    return this.info != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case ID:
      if (value == null) {
        unsetId();
      } else {
        this.id = value;
      }
      break;

    case PATH:
      if (value == null) {
        unsetPath();
      } else {
        this.path = value;
      }
      break;

    case DATA:
      if (value == null) {
        unsetData();
      } else {
        this.data = value;
      }
      break;

    case INFO:
      if (value == null) {
        unsetInfo();
      } else {
        this.info = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case ID:
      return this.id;
    case PATH:
      return this.path;
    case DATA:
      return this.data;
    case INFO:
      return this.info;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case ID:
      return isSetId();
    case PATH:
      return isSetPath();
    case DATA:
      return isSetData();
    case INFO:
      return isSetInfo();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case ID:
          if (field.type == TType.STRUCT) {
            this.id = new TaskID();
            this.id.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case PATH:
          if (field.type == TType.STRING) {
            this.path = iprot.readString();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case DATA:
          if (field.type == TType.STRING) {
            this.data = iprot.readBinary();
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        case INFO:
          if (field.type == TType.STRUCT) {
            this.info = new UploadInfo();
            this.info.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    validate();

    oprot.writeStructBegin(STRUCT_DESC);
    if (this.id != null) {
      oprot.writeFieldBegin(ID_FIELD_DESC);
      this.id.write(oprot);
      oprot.writeFieldEnd();
    }
    if (this.path != null) {
      oprot.writeFieldBegin(PATH_FIELD_DESC);
      oprot.writeString(this.path);
      oprot.writeFieldEnd();
    }
    if (this.data != null) {
      oprot.writeFieldBegin(DATA_FIELD_DESC);
      oprot.writeBinary(this.data);
      oprot.writeFieldEnd();
    }
    if (this.info != null) {
      oprot.writeFieldBegin(INFO_FIELD_DESC);
      this.info.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("UploadFile_args(");
    var first:Boolean = true;

    ret += "id:";
    if (this.id == null) {
      ret += "null";
    } else {
      ret += this.id;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "path:";
    if (this.path == null) {
      ret += "null";
    } else {
      ret += this.path;
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "data:";
    if (this.data == null) {
      ret += "null";
    } else {
        ret += "BINARY";
    }
    first = false;
    if (!first) ret +=  ", ";
    ret += "info:";
    if (this.info == null) {
      ret += "null";
    } else {
      ret += this.info;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

class UploadFile_result implements TBase {
  private static const STRUCT_DESC:TStruct = new TStruct("UploadFile_result");
  private static const SYSTEM_EXCEPTION_FIELD_DESC:TField = new TField("systemException", TType.STRUCT, 1);

  private var _systemException:SystemException;
  public static const SYSTEMEXCEPTION:int = 1;


  public static const metaDataMap:Dictionary = new Dictionary();
  {
    metaDataMap[SYSTEMEXCEPTION] = new FieldMetaData("systemException", TFieldRequirementType.DEFAULT, 
        new FieldValueMetaData(TType.STRUCT));
  }
  {
    FieldMetaData.addStructMetaDataMap(UploadFile_result, metaDataMap);
  }

  public function UploadFile_result() {
  }

  public function get systemException():SystemException {
    return this._systemException;
  }

  public function set systemException(systemException:SystemException):void {
    this._systemException = systemException;
  }

  public function unsetSystemException():void {
    this.systemException = null;
  }

  // Returns true if field systemException is set (has been assigned a value) and false otherwise
  public function isSetSystemException():Boolean {
    return this.systemException != null;
  }

  public function setFieldValue(fieldID:int, value:*):void {
    switch (fieldID) {
    case SYSTEMEXCEPTION:
      if (value == null) {
        unsetSystemException();
      } else {
        this.systemException = value;
      }
      break;

    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function getFieldValue(fieldID:int):* {
    switch (fieldID) {
    case SYSTEMEXCEPTION:
      return this.systemException;
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  // Returns true if field corresponding to fieldID is set (has been assigned a value) and false otherwise
  public function isSet(fieldID:int):Boolean {
    switch (fieldID) {
    case SYSTEMEXCEPTION:
      return isSetSystemException();
    default:
      throw new ArgumentError("Field " + fieldID + " doesn't exist!");
    }
  }

  public function read(iprot:TProtocol):void {
    var field:TField;
    iprot.readStructBegin();
    while (true)
    {
      field = iprot.readFieldBegin();
      if (field.type == TType.STOP) { 
        break;
      }
      switch (field.id)
      {
        case SYSTEMEXCEPTION:
          if (field.type == TType.STRUCT) {
            this.systemException = new SystemException();
            this.systemException.read(iprot);
          } else { 
            TProtocolUtil.skip(iprot, field.type);
          }
          break;
        default:
          TProtocolUtil.skip(iprot, field.type);
          break;
      }
      iprot.readFieldEnd();
    }
    iprot.readStructEnd();


    // check for required fields of primitive type, which can't be checked in the validate method
    validate();
  }

  public function write(oprot:TProtocol):void {
    oprot.writeStructBegin(STRUCT_DESC);

    if (this.isSetSystemException()) {
      oprot.writeFieldBegin(SYSTEM_EXCEPTION_FIELD_DESC);
      this.systemException.write(oprot);
      oprot.writeFieldEnd();
    }
    oprot.writeFieldStop();
    oprot.writeStructEnd();
  }

  public function toString():String {
    var ret:String = new String("UploadFile_result(");
    var first:Boolean = true;

    ret += "systemException:";
    if (this.systemException == null) {
      ret += "null";
    } else {
      ret += this.systemException;
    }
    first = false;
    ret += ")";
    return ret;
  }

  public function validate():void {
    // check for required fields
    // check that fields of type enum have valid values
  }

}

