<?xml version="1.0" encoding="utf-8"?>
<s:WindowedApplication xmlns:fx="http://ns.adobe.com/mxml/2009"
					   xmlns:s="library://ns.adobe.com/flex/spark"
					   xmlns:mx="library://ns.adobe.com/flex/mx"
					   xmlns:local="*"
					   width="650" height="768"
					   applicationComplete="{Config.UI.centerApp(event);loaded=true;}"
					   initialize="{this.init()}"
					   resize="{if (loaded==true) Config.UI.onResize(event)}" showStatusBar="false"
					   title="Snaphappi Desktop Uploader">
	<s:BorderContainer x="0" y="0" width="100%" height="100%"  backgroundColor="#FFFFFF">
		<mx:HTML id="domParent" x="0" y="0" width="100%" height="100%" complete="{onDomReady()}" />
		<mx:Canvas id="dropTarget1"  x="0" y="0" width="100%" height="100%" visible="false" includeInLayout="false" backgroundColor="#FFFFFF" alpha=".2"/>
		<s:BorderContainer id="glass" x="0" y="0" width="100%" height="100%" backgroundAlpha="0.9"
						   contentBackgroundAlpha="1.0" backgroundImage="@Embed('/images/desktop_bg.jpg')"
						   backgroundImageFillMode="clip">
			<s:BorderContainer backgroundColor="#000000" borderColor="#000000"
							   borderStyle="solid" color="#000000" cornerRadius="5"
							   horizontalCenter="0" verticalCenter="0">
				<s:Label id="loading" color="#FFFFFF" fontSize="16" horizontalCenter="0" 
						 paddingBottom="20" paddingLeft="10" paddingRight="10" paddingTop="20"
						 verticalCenter="0">Please wait while we load the application...</s:Label>
			</s:BorderContainer>
		</s:BorderContainer>
	</s:BorderContainer>
	<fx:Script>
		<![CDATA[
			import api.Config;
			import api.ImageScanner;
			import api.Logger;
			import api.MagickUtils;
			import api.Misc;
			import api.PostQueue;
			import api.SimpleRequest;
			import api.SqlHandler;
			import api.UploaderDatasource;
			import api.UploaderUI;
			
			import com.adobe.serialization.json.*;
			
			import flash.desktop.NativeApplication;
			
			import mx.containers.TitleWindow;
			import mx.controls.Alert;
			import mx.utils.StringUtil;			
			
			private var loaded:Boolean = false;
			public var loadwin:TitleWindow;
			public var sql:SqlHandler;
			private var photoScanner:ImageScanner;
			public var logger:api.Logger;
			public var configs:Object = null;	// deprecate
			public var cfg:Object = null;
			public var isUploadQueueRunning:Boolean = false;	
			
			public var UI:UploaderUI;
			public var Datasource:UploaderDatasource;
			
			/**
			 *	set appRoot folder inside project folder if DEBUG=true 
			 * */
			private function checkDebug():Boolean {
				try {
					var devSrc:File = new File('W:\\www-git');	// assume this folder only exists on dev desktops
					if (devSrc.exists && devSrc.isDirectory) {
						Config.DEBUG = true;
						// on dev desktops, use app:src as root folder, unless app: is a privileged directory
						Config.appRoot = File.applicationDirectory;
						if (File.applicationDirectory.nativePath.search('bin-debug') != -1 ) {
							// flex-uploader debug and runtime modes will read from {project folder}/src
							// slice 'bin-debug'
							Config.appRoot = new File(File.applicationDirectory.nativePath.slice(0,-9)).resolvePath('src');
						}
						try {
							// check if we have write privilege in app:
							var testSrc:File = File.applicationDirectory.resolvePath('images/snappi.32.png');
							var testDest:File = Config.appRoot.resolvePath('db/test.png');							
							testSrc.copyTo(testDest, true);
							testDest.deleteFile();
						} catch (e:Error){
							// app: is a privileged folder, use applicationStorage 
							throw new Error(">>> App: is a privileged folder. using AppStorage:");
						}
					} else {
						throw new Error(">>> FORCE DEBUG = false");
					}
				} catch (e:Error){
					Config.appRoot = File.applicationStorageDirectory;
				}
				return Config.DEBUG;
			}
			
			private function init():void{
				Config.init();
				MagickUtils.init();
				var MODE:String = 'prod';	// dev.snaphappi.com
//				MODE = 'dev';				// git.3:88
				// see: bootstrap_html() for actual host values
				
				this.checkDebug();			// set app root folder inside project folder if DEBUG
				
				/*
				* 	Set Config globals
				*/
				Config.Datasource = new UploaderDatasource();
				Config.UI = new UploaderUI(Config.Datasource, dropTarget1);
				
				/*
				*	Load Config constants
				*/
				try {
					MagickUtils.MAX_CONCURRENT_PROCESSES = Config.MAX_CONCURRENT_PROCESSES;
				} catch (e:Error){}
				/*
				* end Config constants
				*/

				// init API bridge, expose javascript to flex
				Config.jsGlobal = domParent.domWindow;
				domParent.domWindow.htmlctrl = this;	// deprecate
				// init API bridge, expose flex to javascript
				domParent.domWindow.flexAPI_UI = Config.UI;
				domParent.domWindow.flex_app_version = Config.version;
				domParent.domWindow.flexAPI_Datasource = Config.Datasource;	
				domParent.domWindow.flex_onYuiDomReady = onYuiDomReady;
				domParent.domWindow.flex_setDropTarget = Config.UI.setDropTarget;
				// create javascript namespace as early as possible
				
				domParent.addEventListener("complete", onYuiDomReadyComplete);
				
				// bootstrap html and logs
				bootstrap_html(domParent, MODE);
				Config.logger = new api.Logger(Config.appRoot.resolvePath("logs"));
				Config.sql = this.checkDbAndCopy();
				Config.Datasource.loadConfig(); //set init configs
				nativeWindow.addEventListener(NativeWindowBoundsEvent.MOVE, Config.UI.onMove);
				
				// MagickUtils.testConvert();
			}	
			
			private function bootstrap_html(domParent:HTML, location:String = 'prod'):void {
				switch (location) {
					case 'prod':
						Config.HOST = "dev.snaphappi.com";
//						Config.HOST = "aws.snaphappi.com";
						break;
					case 'dev':
					default:				
						if (Config.DEBUG) Config.HOST = "git3:88"
						else Config.HOST = "10.1.2.206";
						break;
				}
				var request:URLRequest = new URLRequest("http://"+Config.HOST+"/app/air/js/bootstrap.html");
				var loader:URLLoader = new URLLoader();
				var onload:Function = function(event:Event):void{
					// save to File.applicationStorageDirectory.
					var loader2:URLLoader = URLLoader(event.target);
					var html:String = loader2.data;
					// <base href='' host='' debug='' />
					html = html.replace(':BASE-ATTRIBUTES:', " href='http://"+Config.HOST+"/' host='"+Config.HOST+"' debug='"+Config.DEBUG+"' ");
					var boostrap:File = File.applicationStorageDirectory.resolvePath('boostrap.html');
					var fileStream:FileStream = new FileStream();
					fileStream.open(boostrap, FileMode.WRITE);
					fileStream.writeUTFBytes(html);
					fileStream.close();
					// load as window.location
					domParent.location = Misc.normalizeFilePath(boostrap.nativePath);
				}				
				loader.addEventListener(Event.COMPLETE, onload);
				try
				{
					loader.load(request);
				} 
				catch (error:Error)
				{
					trace("Unable to load URL: " + error);
				}
			}
			
			private function checkDbAndCopy():SqlHandler{
				var blankDb:File = File.applicationDirectory.resolvePath('db/snaphappi-install.db3');
				var sql:SqlHandler, dbRoot:File, replace:Boolean = false;
				if(blankDb.exists){
					dbRoot = Config.appRoot.resolvePath('db');
					if (Config.DEBUG){
						sql = new SqlHandler('snaphappi-DEBUG.db3', dbRoot);
					}
					else {
						sql = new SqlHandler();
					}
					sql.cloneDb(blankDb, replace);
					return sql;
				}else{
					Alert.show("Error: missing db configuration file. Please re-install the application");
				}		
				return null;
			}			
			/**
			 * seems to fire AFTER YUI/domready complete
			 */
			
			private function onDomReady():void {
				glass.visible = false;
			}
			
			public function onYuiDomReadyComplete(evt:Event):void{
				domParent.removeEventListener("complete", onYuiDomReadyComplete);
			}
			
			// called from javascript
			public function onYuiDomReady():void{
				Config.jsGlobal.firebugLog("***********      onYuiDomReady      ******************");
				Config.jsGlobal.firebugLog('>>>>>>>>>> using appRoot=' + Config.appRoot.nativePath);
				Config.jsUploadQueue = Config.jsGlobal.SNAPPI.AIR.UploadQueue;
				Config.SNAPPI = Config.jsGlobal.SNAPPI;	// deprecate
				// set dropTarget to proxy
				try {
					var selector:String = Config.jsUploadQueue.getDropTargetId();
				} catch (e:Error) {
					selector='';
				}
				Config.UI.setDropTarget(selector);
				// start dragdrop listener
				Config.UI.nativeDDAllowed(true);
				
		Config.jsGlobal.firebugLog("Before getDbFile()");
				// DEV show db file
				var dbFile:File = File.applicationDirectory.resolvePath(Config.sql.getDbFile());
				Config.jsGlobal.firebugLog('>>>>>>>>>> using DB File=' + dbFile.nativePath );
				Config.jsGlobal.firebugLog('>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>    flex:onYuiDomReady COMPLETE' );
				var appXml:XML = NativeApplication.nativeApplication.applicationDescriptor;
				Config.jsGlobal.firebugLog('>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>  NativeAppliction:');
				var ns:Namespace = appXml.namespace();
				Config.jsGlobal.firebugLog("Version: " + appXml.ns::versionNumber);
				Config.jsGlobal.firebugLog(NativeApplication.nativeApplication.publisherID);
//				Config.jsGlobal.firebugLog(appXml);
			}
			

			
			
			

//			// deprecated
//			private function normalizeHtml(html:String,urlprefix:String,search:String):String{
//				var rg0:RegExp = /\ssrc\=\"([\s\S]*?)\"/ig; //"cooment only		
//				var rg1:RegExp = /\shref\=\"([\s\S]*?)\"/ig; //"cooment only
//				var m:Array = null;
//				var rg:RegExp;
//				if(search=='src'){
//					rg = rg0;
//				}else{
//					rg = rg1;
//				}
//				m = html.match(rg);
//				if(m && m.length){
//					html = html.replace(rg,function replfn():String{
//						var a:String = arguments[0];
//						if(a.indexOf('http://')<0){
//							a = a.replace(search + '="',search + '="' + urlprefix);
//						}
//						return a;
//					});
//				}   
//				return html;				
//			}
//			// deprecate
//			private function PostUrl():void{
//				loadwin = new xLoader();//PopUpManager.createPopUp(this, xLoader,false);
//				PopUpManager.addPopUp(loadwin,this,true);
//				PopUpManager.centerPopUp(loadwin);
//			} 
//			// deprecate. used by xLoader
//			public function showMsg(s:String):void{
//				PopUpManager.removePopUp(loadwin);
//				Alert.show(s);
//			}
			
			
			
//	        /*
//	         * public methods to fetch castingCall response as async
//	         * params - accept two params first param is json object as cfg e.g. = {
//	         * 															 page:1,
//	         * 															 perpage:10,
//	         * 															 rating:1, //optional
//	         * 															 dateFrom:'2010:20:04 18:22:57', //optional
//	         * 															 dateTo:'2010:20:04 18:22:57', //optional
//	         * 															 tags : 'cars,red' 	 //optional
//	         * 															}
//	         * 			second is callback json {success:fn,failure:fn,arguments:{},scope:obj}	
//			*/		
//			public function getCastingCall(qs:Object,callback:Object):Object{
//				try{
//					var params:Object = callback.arguments;
//				}catch(e:Error){	
//					params = {};
//				}
//				try{
//					var baseurl:String = qs.baseurl || '';
//					var rating:int = qs.rating || -1;
//					var dateFrom:String = qs.dateFrom || '';
//					var dateTo:String = qs.dateTo || '';
//					var tags:String = qs.tags || '';
//					var page:int = qs.page-1; //cause in sqlite page starts from 0
//					var perpage:int = qs.perpage;
//					var whereQuery : String = " where 1=1";
//					if (baseurl) {
//						whereQuery = whereQuery  + " and base_url='" + Config.sql.SQLBug(baseurl) + "'";						
//					}
//					if(rating!=-1){ //if rating defined means not -1
//						whereQuery = whereQuery  + " and rating>=" + rating;
//					}
//					if(StringUtil.trim(dateFrom).length){
//						whereQuery = whereQuery  + " and date_taken>='" + StringUtil.trim(dateFrom) + "'";
//					}
//					if(StringUtil.trim(dateTo).length){
//						whereQuery = whereQuery  + " and date_taken<='" + StringUtil.trim(dateTo) + "'";
//					}
//					if(StringUtil.trim(tags).length){
//						var tgs:Array = tags.split(",");
//						var tagsCond:String = '';
//						for(var i:int;i<tgs.length;i++){
//							if(i>0){
//								tagsCond += ' and ';
//							}
//							tagsCond += " tags like '%" + tgs[i] + "%'";
//						}
//						whereQuery = whereQuery  + ' and ' + tagsCond;
//					}
//					
//					var query:String = "select count(*) as total_rows from photos " + whereQuery;
//					
//					var dt:Array = Config.sql.execQuery(query);
//					var json:Object = {};
//					if(dt && dt.length){
//						var total_rows:int = dt[0]['total_rows'];
//						page = perpage * page;
//						query = "select * from photos " + whereQuery +  " LIMIT " + page + "," + perpage;
//						dt = Config.sql.execQuery(query);
//						if(dt && dt.length){
//							json = Misc.createSnaphappiJSON(dt,total_rows,qs);
//						}
//					}
//					params.success = true;
//					if (callback === null) {
//						return json;
//					} else { 
//						Config.logger.writeJson("getCastingCall",json);
//						callback.success.call(callback.scope || domParent.domWindow,json,params);
//						return true;
//					}
//				}catch(e:Error){
//					params.success = false;
//					logger.writeLog("Error",e.message + '-getCastingCall');
//					if (callback !== null) {
//						callback.failure.call(callback.scope || domParent.domWindow,{error:e.message},params);
//					} 
//					return false;
//				}
//				return false;
//			}	
			public function appAbsPath():String{
				return File.applicationDirectory.nativePath;
			}
			// deprecate
//			private function getBaseUrl():String{
//				//return (root_folder.text=='[Current Root Folder]')?'':root_folder.text;
//				Config.logger.writeJson("getBaseUrl",this.cfg.baseurl);
//				return this.cfg.baseurl || '';
//			}
			public function setUpdateServerUrl(url:String):Boolean{
				var flag:Boolean = false;
				try{
					Config.Datasource.saveConfig("updateServerUrl",url);
					flag = true;
				}catch(e:Error){
					logger.writeLog("Error",e.message + '-setUpdateServerUrl');
				}
				return flag;
			}


			public function getUpdateServerUrl():String{
				if(this.configs && this.cfg.updateServerUrl){
					return this.cfg.updateServerUrl;
				}else{
					return '';
				}
			}
			public function postData(photos:Array,cb:Object):void{
				var pq:PostQueue = new PostQueue(this.getUpdateServerUrl(),true);
				pq.sql = Config.sql;
				pq.reQueue(photos,cb); 				
			}
			public function getItemCount(base_url:String):int{
				var count:int = 0;
				try{
					base_url = base_url || '';
					if(StringUtil.trim(base_url).length==0){
						base_url = Config.Datasource.cfg.baseurl;
					}
					var query:String = "select count(*) as totals from photos"; 
					if(base_url!='*' && base_url!='all'){
						query += " where base_url='" + Config.sql.SQLBug(base_url) + "'";
					}
					var dt:Array = Config.sql.execQuery(query);
					if(dt && dt.length){
						count = dt[0]['totals'];
					}
				}catch(e:Error){
					logger.writeLog("Error",e.message + '-getItemCount');
				}
				return count;
			}
			
			private function isOldSessionCompleted():Boolean{
				var query:String = "select count(*) as tot_avail from uploadQueues where status!='done' and updated_on=''";
				var dt:Array = Config.sql.execQuery(query);
				var tot_avail:int=0;
				if(dt && dt.length){
					tot_avail = dt[0]['tot_avail'];
				}
				return (tot_avail==0);
			}

			/*
		   * clear all and stop the queue based on status 
		   * params - accept two params 
		   * 			1. status as string e.g. pending/error/cancelled/all
		   *			2. batch_id optional
		   * return - bool - true/false
		   * */
		   public function clear(status:String="all",batch_id:String=''):Boolean{
		   		var flag:Boolean = false;
		   		status = status || 'all';
		   		try{
		   			var updated_on:String = Misc.convertDateStr(new Date()); 
					var query:String = "DELETE FROM uploadQueues WHERE status!='done'";
					var batch_id:String = this.cfg.batch_id || '';
					if (batch_id) query += " AND batch_id='" + batch_id + "'"; 
					
					status = StringUtil.trim(status);
					if(status!="all"){
						query += " AND status='" + status + "'";	
					}
					Config.sql.execNonQuery(query);
					//this.isUploadQueueRunning = false;
					flag = true;
		   		}catch(e:Error){
		   			logger.writeLog("Error",e.message + '-clear');
		   		}
		   		return flag;		
		   }
			// DEPRECATE. run from JS
		   public function pauseQueue():Boolean{
		   		var flag:Boolean = false;
		   		try{
		   			//if(this.isUploadQueueRunning){
		   				domParent.domWindow.SNAPPI.AIR.uploadQueue.doPause();
		   			//	this.isUploadQueueRunning = false;
		   			//}
		   			flag = true;
		   		}catch(e:Error){
		   			logger.writeLog("Error",e.message + '-pauseQueue');	
		   		}
		   		return flag;
		   }
		   /*
		    * used to startQueue
		    * params - no params
		    * return - bool true/false
		    * */ 
			// DEPRECATE. START FROM JS USING SNAPPI.AIR.uploadQueue.action_start()
		   public function startQueue():Boolean{
		   		var flag:Boolean = false;
		   		try{
		   			if(this.getUploadHostOfQueue().length==0){
		   				throw new Error("Set Upload Host First To Run Upload Queue");
		   			}
		   			//check if any batch have photos to upload then startQueue
		   			//if(!this.isOldSessionCompleted()){
		   				//check if already running queue then don't start again
		   				//if(!this.isUploadQueueRunning){
							var batch_id:String = this.cfg.batch_id || '';
							var query:String = "SELECT * FROM uploadQueues WHERE 1=1";
							if (batch_id) query += " AND batch_id='" + batch_id +"'";
							query += " ORDER BY id";
							var dt:Array = Config.sql.execQuery(query);
							var perpage:int = Config.UI.getUploadQueuePerpage();
							var pages:int = 0;
							if(dt && dt.length){
								pages = Math.ceil(dt.length/perpage);
							}
							//set and show div position
							//TODO: need to pass uploader object to domParent
							domParent.domWindow.SNAPPI.AIR.uploadQueue.initQueue(pages,perpage,dt);
			   				//queue started here
			   				//this.isUploadQueueRunning = true;
		   				//}
		   				flag = true;
		   			//}else{
		   			//	throw new Error("Upload Queue Is Empty.");
		   			//}
		   		}catch(e:Error){
		   			logger.writeLog("Error",e.message + '-startQueue');
		   		}
		   		return flag;	
		   }	
		    /*
		     * to get photos from current active upload batch
		     * based on status e.g. pending/error/done/all. default status is 'all'
		     * params - accept one param as a string e.g. status = pending/error/done/all
		     * return - array of json of photos e.g. [
		     * 										  {
		     * 											photo_id : 'photo_id',
		     * 											batch_id : 'batch_id',
		     * 											status : 'pending/error/done',
		     * 											}	 
		     * 										 ]
		     *  
		     * */
		     public function getCurrentUploadStatus(status:String):Array{
		     	status = status || 'all';
		     	var arr:Array = [];
		     	try{
		     		var batch_id:String = this.cfg.batch_id || '';
					var query:String = "SELECT * FROM uploadQueues WHERE 1=1";
					if (batch_id) query += " AND batch_id='" + batch_id + "'"; 
					if(status!='all'){
						query += " AND status='" + status + "'";
					}	
					var dt:Array = Config.sql.execQuery(query);
					if(dt && dt.length){
						arr = dt;
					}
		     	}catch(e:Error){
		     		logger.writeLog("Error",e.message + '-getCurrentUploadStatus');
		     	}
		     	return arr;
		     }
		     /*
			* deprecated. use UploaderUI.setUploadQueueStatus() instead
		      * sends error(not uploaded due to some reason) while uploading set back to running queue
		      * params - no param
		      * return - bool return/false
		      * */
		     public function retryUpload():Boolean{
		     	var flag:Boolean = false;
		     	try{
					var batch_id:String = this.cfg.batch_id || '';
					var query:String = "SELECT uq.id,uq.photo_id,uq.batch_id,uq.status,p.rel_path " +
						" FROM uploadQueues as uq, photos as p " + 
						" WHERE p.id=uq.photo_id AND status='error'";
					if (batch_id) query += " AND uq.batch_id='" + batch_id + "'";  
					query += " ORDER BY uq.id ";
									   
					var dt:Array = Config.sql.execQuery(query);
					if(dt && dt.length){
						query = "UPDATE uploadQueues SET status='pending', updated_on=''" +
							" WHERE status='error'";
						if (batch_id) query += " AND batch_id='" + batch_id + "'";  
						Config.sql.execQuery(query);
						domParent.domWindow.SNAPPI.AIR.uploadQueue.doRetry(dt || []);
						flag  = true;
					}		     		
		     	}catch(e:Error){
		     		logger.writeLog("Error",e.message + '-retryUpload');
		     	}
		     	return flag;
		     }

			// deprecate
		     public function setUploadHostFromServer(url:String,cb:Object):void{

		     }
	       /*
	        * set upload host server for current upload queue  
	        * params - it accept one string as a host e.g. http://localhost:8080/test/upload.php
	        * return - no return value
	        * */
	        public function setUploadFilePOSTurl(host:String):void{
				Config.Datasource.saveConfig('uploadHost',host);
	       	}
	       /*
	        * get upload host server of currently set upload queue  
	        * params - no params
	        * return - return string as a host e.g. http://localhost:8080/test/upload.php or empty string if not set
	        * */
	        public function getUploadHostOfQueue():String{
	       		return this.cfg.uploadHost || '';
	        }
	        
//	        public function setUploadQueuePerpage(uploadQueuesPerpage:Number):void{
//	        	Config.Datasource.saveConfig('uploadQueuesPerpage',uploadQueuesPerpage + '');
//	        }
//	        public function getUploadQueuePerpage():int{
//	        	return parseInt(this.cfg.uploadQueuesPerpage || '10',10);
//	        }
			public function getQueuedPhotos(cfg:Object):Array{
				cfg = cfg || {};
				var status:String = cfg.status || 'all';
				var perpage:int = cfg.perpage || 9999;
				var page:int = cfg.page || 1;
				var pageitems:Array = [];
				try{
					var batch_id:String = this.cfg.batch_id || '';
					var xpage:int = page-1;
					xpage = perpage * xpage;
					var query:String = "SELECT uq.id,uq.photo_id,uq.batch_id,uq.status,p.rel_path,p.rating,p.tags" +
						" FROM uploadQueues as uq ,photos as p " + 
						" WHERE p.id=uq.photo_id";
					if (batch_id) query += " AND batch_id='" + batch_id + "'"; 
					if(StringUtil.trim(status).length>0 && status!='all'){
						query += " AND status='" + status + "'";
					}				   
					query += " ORDER BY uq.id LIMIT " + xpage + "," + perpage;
					var dt:Array = Config.sql.execQuery(query);
					dt = dt || [];
					pageitems = dt;
				}catch(e:Error){
					Config.logger.writeLog("Error",e.message + '-getPageItems');
				}	
				Config.logger.writeJson("getQueuedPhotos",pageitems);
				return pageitems;
			}
			
	        
		    public function getStaleData():Array{
		     	var arr:Array = [];
		     	try{
					var query:String = "select * from photos where isStale=true"; 
					var dt:Array = Config.sql.execQuery(query);
					if(dt && dt.length){
						arr = dt;
					}
		     	}catch(e:Error){
		     		logger.writeLog("Error",e.message + '-getStaleData');
		     	}
		     	return arr;
		    }
		    
		    public function startSyncQueue(callBackOnEveryPost:Boolean,cb:Object):void{
		    	var staleData:Array = this.getStaleData();
				var pq:PostQueue = new PostQueue(this.getUpdateServerUrl(),callBackOnEveryPost);
				pq.sql = Config.sql;
				pq.postStaleData(staleData,cb); 				
		    }
		    public function getPhotosBy(cfg:Object):Array{
		     	var arr:Array = [];
		     	try{
					var query:String = "select * from photos";
					query += " where 1=@runq";
					var key:String = '';
					var params:Array = [];
					params.push({name:'@runq',value:1});
					for(key in cfg){
						var name:String = "@" + key;
						var value:* = cfg[key];
					 	query += " and " + key + "=" + name;
					 	params.push({name:name,value:value});   
					} 
					var dt:Array = Config.sql.executeQueryParams(query,params);
					if(dt && dt.length){
						arr = dt;
					}
		     	}catch(e:Error){
		     		logger.writeLog("Error",e.message + '-getStaleData');
		     	}
		     	return arr;
		    }
		    public function setSyncFromServerUrl(url:String):void{
		    	Config.Datasource.saveConfig('syncFromServerUrl',url);
		    }
		    public function getSyncFromServerUrl():String{
		    	return this.cfg.syncFromServerUrl || '';
		    }
		    private function syncPhotos(dt:Array):void{
		    	for(var i:int=0;i<dt.length;i++){
		    		var json:Object = dt[i];
		    		json.id = json.id || json.photo_id;
		    		Config.Datasource.updatePhotoProperties(json);
		    	}
		    }
		    public function syncFromServer(lastupdate:String,callback:Object):void{
		     	try{
		     		var url:String = this.getSyncFromServerUrl();
		     		var sReq:SimpleRequest = new SimpleRequest();
		     		var mycb:Object = {
		     			scope : this,
		     			success : function(e:String,params:Object):void{
		     				var data:* = JSON.decode(e);
		     				if(data){
		     					var lastupdate:String = Misc.convertDateStr(new Date());
		     					Config.Datasource.saveConfig('lastupdate',lastupdate);
		     					var dt:Array = data as Array;
		     					this.syncPhotos(dt);
		     					params.success.call(params.scope || domParent.domWindow ,data ,params.arguments);
		     				}else{
		     					params.failure.call(params.scope || domParent.domWindow ,"Invalid JSON " + e,params.arguments);
		     				}	
		     			},
		     			failure : function(e:String,params:Object):void{
		     				params.failure.call(params.scope || domParent.domWindow ,e,params.arguments);
		     			},
		     			arguments : callback
		     		};
		     		sReq.sendRequest(url,'data["provider_key"]=' + this.cfg.provider_key + '&data["lastupdate"]=' + lastupdate,mycb);
		     	}catch(e:Error){
		     		logger.writeLog("Error",e.message + '-syncFromServer');
		     		callback.failure.call(callback.scope || domParent.domWindow ,e.message,callback.arguments);
		     	}
		    }
		    
		    public function getLastSyncTime():String{
		    	var lastupdate:String = '';
		    	try{
		    		lastupdate = this.cfg.lastupdate || '';
		     	}catch(e:Error){
		     		logger.writeLog("Error",e.message + '-getLastSyncTime');
		     	}	
		     	return lastupdate;
		    }
		    
		    public function setSyncAndSetDataUrl(url:String):void{
		    	Config.Datasource.saveConfig('syncAndSetDataUrl',url);
		    }
		    public function getSyncAndSetDataUrl():String{
		    	return this.cfg.syncAndSetDataUrl || '';
		    }
		    
		    public function syncAndSetData(json:Object,cb:Object):void{
		     	try{
		     		var url:String = this.getSyncAndSetDataUrl();
		     		var sReq:SimpleRequest = new SimpleRequest();
		     		var mycb:Object = {
		     			scope : this,
		     			success : function(e:String,params:Object):void{
		     				var data:String = e;
		     				if(StringUtil.trim(data).toLowerCase()=="success"){
		     					var obj:Object = params.json;
		     					this.updatePhotoProperties(obj);
		     					params.cb.success.call(params.cb.scope || domParent.domWindow ,"success" ,params.cb.arguments);
		     				}else{
		     					params.cb.failure.call(params.cb.scope || domParent.domWindow ,e,params.cb.arguments);
		     				}	
		     			},
		     			failure : function(e:String,params:Object):void{
		     				params.cb.failure.call(params.cb.scope || domParent.domWindow ,e,params.cb.arguments);
		     			},
		     			arguments : {
		     				json : json,
		     				cb : cb
		     			}
		     		};
		     		var jsonkeys:String = '';
		     		for(var key:String in json){
		     			jsonkeys += '&data["' + key + "]=" + escape(json[key]);  
		     		}
		     		sReq.sendRequest(url,'data["provider_key"]=' + this.cfg.provider_key + jsonkeys ,mycb);
		     	}catch(e:Error){
		     		logger.writeLog("Error",e.message + '-syncAndSetData');
		     		cb.failure.call(cb.scope || domParent.domWindow ,e.message,cb.arguments);
		     	}
		    }
		    
		    public function saveLoginInfo(username:String,password:String):Boolean{
		    	var flag:Boolean = false;
		    	try{
		    		var query:String = "insert into tbusers(username,password) values(@uname,@pass)";
		    		var params:Array = new Array();
		    		params.push({name:'@uname',value:username});
		    		params.push({name:'@pass',value:password});
		    		Config.sql.executeNonSQLParams(query,params);
		    		flag = true;
		    	}catch(e:Error){
		    		Config.logger.writeLog("Error",e.message + '-saveLoginInfo');
		    	}
		    	return flag;
		    }

		    public function getLoginInfo():Object{
		    	var obj:Object = {};
		    	try{
		    		var query:String = "select username,password from tbusers";
		    		var dt:Array  = Config.sql.execQuery(query);
		    		if(dt && dt.length){
						obj = dt[0];		    			
		    		}
		    	}catch(e:Error){
		    		Config.logger.writeLog("Error",e.message + '-getLoginInfo');
		    	}
		    	return obj;
		    }

		    private function startQ():void{
		    	this.startQueue();
		    } 
		    
		]]>
	</fx:Script>
	<!--
	<fx:ApplicationControlBar dock="true" fillAlphas="[1.0, 1.0]" fillColors="[#006699, #FFFFFF]">
		<fx:Button label="Scan Root Folder" click="selectRootFolder();"/>
		<fx:Label text="[Scanned]" id="scan_info"/>
		<fx:Label text="[Added]" id="added_info"/>
		<fx:Label text="[Updated]" id="updated_info"/>
		<fx:Label text="[Existing]" id="existing_info"/>
		<fx:Label text="[Current Root Folder]" id="root_folder"/>
		<fx:Button label="startQueue" click="startQ()"/>
	</fx:ApplicationControlBar>	
	-->

	
</s:WindowedApplication>
